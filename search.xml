<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS多工程依赖]]></title>
      <url>%2F2016%2F12%2F25%2FiOS%E5%A4%9A%E5%B7%A5%E7%A8%8B%E4%BE%9D%E8%B5%96%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;在日常开发中，有时候我们为了保持整个项目的结构清晰，需要对项目的不同的类进行模块化，其中使用工程依赖是个不错的选择。 准备工作1，新建一个workspace工程，我创建了一个TestDemo工程然后引入cocoapods.2，然后新建一个静态库工程，建立方法Framework &amp; Library-&gt;Cocoa Touch Static Library取名为LJCommonUI，注意：这个静态库工程与第一个工程分开创建3，将LJCommonUI拖进基础工程的文件夹 建立相关引用1，打开基础工程，Add Files to…，把LJCommonUI引入添加完如下图2，设置Header Path, Build Setting-Header Search Paths (添加头文件搜索路径)3，引入.a文件, Build Phases - Link Binary With Libraries 添加LJCommonUI.a注意：1，如果LJCommonUI里面有图片或者其他的依赖库B-Build Phases - Copy Files添加对应的图片和依赖库2，如果LJCommonUI里有category，使用category的时候会crashB-Other Linker Flags 添加-Objc和-all_load确保category被正常引入 打包注意事项有依赖库的时候，Archive通常在organize里找不到项目或者没有version和identifier要把依赖库LJCommonUI - Build Settings - Skip Install设置为YES，但项目TestDemo - Skip Install设置为NO]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS文件统一管理]]></title>
      <url>%2F2016%2F12%2F10%2FiOS%E6%96%87%E4%BB%B6%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;最近在做我们公司自己的项目时，遇到了一个难题，就是随着用户使用我们公司的app时间越久，便导致app沙盒文件越来越多，严重时我查看我们公司的app使用内存量达到了7.3G，查看方式，打开你的苹果手机,(设置-通用-储存空间及iCloud用量-管理储存空间);怎么样不查不知道一查是不是吓一跳？&emsp;&emsp;细说下我们公司app占用内存量大的原因，我们公司的app属于类社交和OA类，其中有类似微信的朋友圈和聊天，及收藏功能，所以当用户发图片很多时，图片都存入自己的沙盒中，当用户在聊天页面点击图片收藏，图片会复制一份并生成新的图片再次上传服务器，同时新生成的图片也会copy到我们已经规定好的沙盒中的收藏文件夹(之所以给每个模块都在沙盒目录中规定一个文件夹，为了便于清理,注：每个聊天会话的图片都存在它特定的文件夹下，删除某一条会话时，会话下的图片也能得到及时清除)下。同理，在朋友圈中的图片也可以收藏。所以当图片少的时候暂时没有发现问题，而且似乎感觉还很好，因为每次文件清理直接拿到每一个模块的路径文件夹清理就可以。然而，随着时间的推移，用户选择的文件的越来越多，便产生一开始描述的问题。附路径地址：/Users/liangju/Library/Developer/CoreSimulator/Devices/6184D61E-A799-4127-881E-F71E3D9CD61B/data/Containers/Data/Application/F83F1BC6-4809-40B9-80EC-D1EC7FEF2FBA/Documents/my_app/1BdWrWKyJ8MUpM7ofJsa4g/file/CC_OPEN_MESSAGE/g_2BwfR0iZJedUvP6ispaOAp/168D8A9C8830461AAC6C6711C9136115.jpg /Users/liangju/Library/Developer/CoreSimulator/Devices/6184D61E-A799-4127-881E-F71E3D9CD61B/data/Containers/Data/Application/F83F1BC6-4809-40B9-80EC-D1EC7FEF2FBA/Documents/my_app/1BdWrWKyJ8MUpM7ofJsa4g/file/CC_OPEN_MESSAGE/ u_2aRr2i4UF5dkXExQMVTly1I/317C7D7B10D847B09F4CE827BC8EB78F.jpg其中地址中my_app 为app名字，1BdWrWKyJ8MUpM7ofJsa4g为登录人id，CC_OPEN_MESSAGE为服务id，也就是下文中的SERV_ID，u_2aRr2i4UF5dkXExQMVTly1I为绘画id，其中我们公司规定以u开头是单人绘画，g开头为群组绘画，同时此项也就是下文中的DATA_ID，再往下就是image对象名字了&emsp;&emsp;所以便想能不能把这些文件统一管理起来，比如聊天中的图片再收藏时(前提此图片已经上传服务器成功，上传失败的情况我们稍后讨论)，能不能不在复制产生新的图片上传，收藏模块的图片直接去聊天的那张图片路径下，把这张图片读出显示。&emsp;&emsp;实现篇:统一封住文件最终下载所调的接口。每个文件下载时都给它固定了一个下载路径。当它下载成功后，把文件对应的服务器的文件id，保存到数据表中。结合每个公司的不同情况合理设置缓存模型，我们公司的设置如下： 1234567891011121314151617181920// 文件在服务端的id @property (nonatomic, copy) NSString *SERVER_FILEID;// 功能分类:例如：在聊天中就是CC_OPEN_MESSAGE@property (nonatomic, copy) NSString *SERV_ID;// 在chat功能中就是msgId@property (nonatomic, copy) NSString *DATA_ID;// 文件长度@property (nonatomic, copy) NSString *FILE_SIZE;// 待定：数据创建时间@property (nonatomic, copy) NSString *S_ATIME;// 待定：数据创建时间@property (nonatomic, copy) NSString *S_MTIME;// 本地相对路径@property (nonatomic, copy) NSString *PATH; 其次在每次下载图片的时候，1，先从sd内存缓存里读出图片，若读出直接block image对象；2，若不存在image，则需要先根据SERVER_FILEID查一下本地是否已经存在那条数据，如果存在，根据路径读出图片，再根据SERV_ID、DATA_ID、SERVER_FILEID再次查找本地表是否存在这条数据，如果不存在，则新建一条数据；当根据SERVER_FILEID在本地表中查找不到时，继续往下走，调用图片下载方法(我们采用的图片下载三方为sd),以下为相关代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687- (void)rh_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock rhImgParam:(RHImageParam *)rhImgParam &#123; //modify if (!url) &#123; return; &#125; NSDictionary *dict = [RHFileCacheHelper getServeFileIdAndImageSizeWithServerUrl:url]; NSString *fileId = dict[@"FIELD"]; NSString *image_size = dict[@"IMG_SIZE"]; NSDictionary *paramDict = rhImgParam.extraDict; NSString *serv_Id = paramDict ? paramDict[@"SERV_ID"] : @""; NSString *data_Id = paramDict ? paramDict[@"DATA_ID"] : @""; if (rhImgParam.category) &#123; url = [[RHWebImageManager sharedManager] changeURL:url param:rhImgParam]; &#125; // 0 表示未传值 (默认) if (options == 0 || ((options &amp; SDWebImageRefreshCached) != SDWebImageRefreshCached)) &#123; // 1，内存缓存读出图片 NSString *key = [rhImgParam.manager cacheKeyForURL:url]; UIImage *image = [rhImgParam.manager.imageCache imageFromDiskCacheForKey:key]; if (image) &#123; self.image = image; if (completedBlock) &#123; completedBlock(image, nil, SDImageCacheTypeMemory, url); &#125; return; &#125; else &#123; // 2，从缓存表中读出图片 if ([image_size integerValue] &gt; 300) &#123; image = [RHFileCacheHelper fetchSqlCacheImageWithServId:serv_Id dataId:data_Id serFileId:fileId]; if (image) &#123; // servId dataId servFileId self.image = image; if (completedBlock) &#123; completedBlock(image, nil, SDImageCacheTypeDisk, url); &#125; return; &#125; &#125; &#125; &#125; [self rh_cancelCurrentImageLoad]; objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC); if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; self.image = placeholder; &#125;); &#125; if (url) &#123; __weak __typeof(self)wself = self;// id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; id &lt;SDWebImageOperation&gt; operation = [rhImgParam.manager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (!wself) return; dispatch_main_sync_safe(^&#123; if (!wself) return; if (image) &#123; wself.image = image; [wself setNeedsLayout]; if (([image_size integerValue] &gt; 300) &amp;&amp; image) &#123; // 保存图片到缓表的操作 NSString *fileName = [RHTools cachedFileNameForKey:url.absoluteString param:rhImgParam]; NSString *fullPath = [RHCommonHelper getCacheFileFullPathWithServID:serv_Id dataId:data_Id imageId:fileName]; NSInteger length = [UIImageJPEGRepresentation(image,1) length]; RHFileCacheModel *fileModel = [RHFileCacheHelper getFileCacheModelWithServ_Id:serv_Id dataId:data_Id server_FileId:fileId fileLocalFullPath:fullPath fileSize:([NSString stringWithFormat:@"%ld", (long)length])]; [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel]; &#125; &#125; else &#123; if ((options &amp; SDWebImageDelayPlaceholder)) &#123; wself.image = placeholder; [wself setNeedsLayout]; &#125; &#125; if (completedBlock &amp;&amp; finished) &#123; completedBlock(image, error, cacheType, url); &#125; &#125;); &#125;]; [self sd_setImageLoadOperation:operation forKey:@"UIImageViewImageLoad"]; &#125; else &#123; dispatch_main_async_safe(^&#123; NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @"Trying to load a nil url"&#125;]; if (completedBlock) &#123; completedBlock(nil, error, SDImageCacheTypeNone, url); &#125; &#125;); &#125;&#125; 1234567891011121314151617181920212223242526272829/** * 根据servId、dataId，serFileId读出混存表中的图片 * @param servId 服务id * @param dataId dataid * @param serFileId 服务端文件id * @return image对象 */+ (UIImage *)fetchSqlCacheImageWithServId:(NSString *)servId dataId:(NSString *)dataId serFileId:(NSString *)serFileId &#123; NSArray *fileArray = [[RHFileCacheManager sharedInstance]fetchFileCacheFileWithServer_FileId:serFileId]; // 根据serFileId 查询缓存表并转换为缓存model读出 if (fileArray.count &gt; 0) &#123; RHFileCacheModel *fileModel = [fileArray firstObject]; // 缓存model NSString *path = [RHCommonHelper getFullPathWithRelativePath:fileModel.PATH]; // 获取图片的全路径 UIImage *image = [UIImage imageWithContentsOfFile:path]; if (image) &#123; // servId dataId servFileId NSArray *tmpArray = [[RHFileCacheManager sharedInstance]fetchFileCacheFileWithServId:servId dataId:dataId serverFileId:serFileId]; if (tmpArray.count == 0) &#123; fileModel.ID = [RHTools stringUUID]; // uuid 随机生成的数据 fileModel.S_ATIME = [RHDateTools currenTime]; fileModel.S_MTIME = [RHDateTools currenTime]; fileModel.SERV_ID = servId; fileModel.DATA_ID = dataId; fileModel.SERVER_FILEID = serFileId; [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel]; &#125; return image; &#125; &#125; return nil;&#125; 接下来我们来处理图片上传的情况：在上传图片接口；无论成功，失败都要将其结果保存数据库，只是失败时不存在SERVER_FILEID；其次在处理上传成功的图片，在其保存前先根据SERV_ID，DATA_ID，PATH查寻缓存表，看这条数据是否已经存在，若存在，只需更新表，把SERVER_FILEID更新至表中，若不存在，则生成一条新的数据保存至表中。 123456789101112131415161718192021/** 处理上传成功的图片 * @param servId 服务Id * @param dataId dataId * @param serverFileId 服务端文件Id * @param fullPath 全路径 * */+ (void)dealSuccessPhotosWithServId:(NSString *)servId dataId:(NSString *)dataId serverFileId:(NSString *)serverFileId fileLocalFullPath:(NSString *)fullPath &#123; if ([RHTools checkIfPreviewImage:serverFileId] &amp;&amp; [FCFileManager existsItemAtPath:fullPath]) &#123; // 根据serverFileId后缀名检查是否是图片，并且本地路径下是否存在该文件 NSArray *cacheOldArr = [[RHFileCacheManager sharedInstance]fetchFileCacheFileWithServId:servId dataId:dataId fullPath:fullPath]; RHFileCacheModel *fileModel = [[RHFileCacheModel alloc]init]; if (cacheOldArr.count == 0) &#123; // 缓存表中不存在这一条记录 fileModel = [self p_getFileCacheModelWithServId:servId dataId:dataId serverFileId:serverFileId fileLocalFullPath:fullPath]; // 生成缓存模型 &#125; else &#123; fileModel = [cacheOldArr firstObject]; fileModel.PATH = [RHCommonHelper getRelativePathWithfullPath:fullPath]; // 根据全路径获取相对路径 fileModel.SERVER_FILEID = serverFileId; &#125; [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel]; // 保存到缓存表&#125; 12345678910111213141516/** * 处理上传失败的图片数组 * @param servId 服务iId * @param dataId dataId * @param failures 失败数组 */+ (void)dealPostFailPhotosWithServId:(NSString *)servId dataId:(NSString *)dataId failures:(NSArray *)failures &#123; for (NSDictionary *content in failures) &#123; NSString *fullpath = content[@"fileURL"]; if ([FCFileManager existsItemAtPath:fullpath]) &#123; RHFileCacheModel *fileModel = [self p_getFileCacheModelWithServId:servId dataId:dataId serverFileId:@"" fileLocalFullPath:fullpath]; [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel]; &#125; &#125;&#125; &emsp;&emsp;删除逻辑:删除时首先根据SERVER_FILEID查表中数据，如果大于1，说明此文件被多个地方引用，不删除文件，仅根据SERV_ID，DATA_ID，SERVER_FILEID，删出表中这条数据；若根据SERVER_FILEID查表中数据等于1，删除文件，同时根据SERV_ID，DATA_ID，SERVER_FILEID，删出表中这条数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我曾经经历的CMMI3认证之关于软件开发人员的访谈]]></title>
      <url>%2F2016%2F10%2F29%2F%E6%88%91%E6%9B%BE%E7%BB%8F%E7%BB%8F%E5%8E%86%E7%9A%84CMMI3%E8%AE%A4%E8%AF%81%E4%B9%8B%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E8%AE%BF%E8%B0%88%2F</url>
      <content type="text"><![CDATA[自己所在的公司申请CMMI3等级认证，本人又有幸成为了被访谈中的一员，我由于本人从属于公司的研发部的一名研发人员，所以我的身份顺理成章的也是开发人员。主评官是一名德国老外。 当时我们公司和对方约定的访谈时间是10月18日~10月21日，第一天首先是发起人见面，然后要参加被访谈的全体人员参加启动会议，下午是分别是EPG组长、CM、OT、PPQA的访谈，开发人员是19号。 我们公司一共准备了3个项目(每个项目组配备两名开发人员，一名测试人员)，我是第一个项目组的成员，早晨9点钟到达公司，大概9:15左右，会议室的人出来叫人说可以开始了，让我们进去，进入到会议室之后老外先和我们打了招呼，然后翻译在旁翻译，并且讲述访谈的原则不归咎原则，及签订保密协议。 下面是我们访谈的被问到的问题：1，公司定义了哪些不同的需求获取的方式？答：公司定义的需求获取的方式有：电话、邮件、调查问卷、开研讨会、静态页面效果图、原型等方式2，你的项目中使用了哪些方式获取客户的需求的？获取了客户的哪些需求？答：邮件、调查问卷、开研讨会、静态页面效果图；获取了客户的需求分为功能性需求和质量属性方面的需求，质量属性方面的需求可分为可维护性，安全性，易用性等等。3，客户有没有对你们获取后的需求进行确认？如何确认的？答：我们将用户的需求整理，制定成《用户需求说明书》并交与客户确认签字。4，项目中的需求是如何进行管理的？答：我们在每个阶段完成时，都填写《需求跟踪矩阵》，所以当需求变更时，我们《需求跟踪矩阵》来查看每个需求的状态，了解因变更而影响的需求范围。5，你们是如何对客户的需求进行分析的？答：我们采用VISO工具来分析系统，并对系统进行建模，制定出系统的业务流程图和系统架构图，当《软件需求说明书》制定完成后，由项目经理组织邀请客户，开发人员，测试人员，配置人员，质量保证人员，高层参加软件需求说明书的评审会议，在保证需求分析是满足客户需求的，并得到大家的认可。6，需求的优先级和难易度是如何来定义的？答：我们是根据需求的难易度来确定优先级的。高 — 软件必须实现的功能，用户有明确的功能定义和要求；中 — 软件应该实现的功能，用户的功能定义和要求可能是模糊的、不具体的、或低约束的，但是这类功能的缺少会导致用户的不满意，因此这类功能的具体需求应当由需求分析人员诱导用户产生并明确；低 — 软件尽量实现的功能，并可根据开发进度进行取舍，但这类功能的实现将会增加用户的满意度。7，公司是如何跟踪项目的需求接口需求的？答：根据《用户需求说明书》指定的《软件需求说明书》中定义了软件的接口需求。并在《需求跟踪矩阵》中进行接口需求的跟踪。8，如何对需求进行管理来确保需求的完整性，一致性？答：通过评审会议，维护《需求跟踪矩阵》，以及周会确保需求的完整性和一致性。9，需求变更的时候由谁来确认？答：当需求变更的时候，由项目经理提交需求变更申请到CCB(变更控制委员会)进行确认是否变更。10，你们怎么确保不同工作产品的一致性和完整性？答：通过召开评审会议确保不同工作产品的一致性和完整性。11，对于过程改进活动，你们参与了哪些工作？答：参与了临时过程组对OSSP体系对编写，需求开发与管理，设计过程等。12，需求经验和优秀实践经验如何和其他项目和组织分享？答：一般有好的经验或建议，我们会向EPG反馈，EPG组长整理采纳后会存放在公司的财富库中。13，在过程规范中变更如何通知你们的？答：过程规范发生变更时，过程改进会形成新的基线，配置管理工程师会发布基线报告，EPG组长会安排相应人员给我们培训。14，如何管理产品交付后客户的需求？答：在产品交付客户后，我们给客户有1年的免费维护期，如果是原需求的变更，我们免费维护，如果新需求的变更，则另有偿维护。15，公司是否通过了设计方面的指南？答：是的，EPG制定了《设计过程》《实现过程》等来指导我们工作。16，设计过程是什么？答：项目经理指定角色，要先做《概要设计说明书》和《编码规范》，然后召开评审会议，评审通过后，再做《详细设计说明书》及《数据库设计说明书》，同时界面设计师做静态界面设计，然后由项目经理召开评审会议，评审通过后，将相关配置项由配置管理工程师入库等。17，设计采用了哪些技术？答：结构化设计方法：1，自顶向下 2，逐步细化 3，模块化设计 4，结构化编码结构化设计步骤如下：1，审核细化数据流2，确定数据流程图的类型3，把数据流图映射到软件模块结构，设计出模块结构的上层4，基于数据流图逐步分解高层模块，设计中下层模块5，对模块结构进行优化，得到更合理的软件结构6，描述模块接口18，目前的决策分析方法有哪些？答：主要采用了经验法和类比法两种。然后采用专家法打分决策19，项目中的重用组件使用前，项目组有没有进行讨论？答：在《项目计划》里定义并分析了项目重用组件，并在《项目计划》会议上，对项目的组件重用进行了分析讨论。20，设计阶段你们做了哪些评审，如何做的？答：设计阶段有《概要设计说明书》评审，《详细设计说明书》评审；《里程碑》等评审活动，在评审会议上，由主持人组织会议持续，作者讲解评审工作的内容，回答评审人员提出的问题，会议记录人员将会议上的内容及问题进行记录，并整理到《评审记录》中，由项目经理指定并监控负责人解决评审中发现的问题。21，关于这些评审，计划多少的工作量？评审的主要反馈是什么？答：评审会议一般持续4个小时左右，评审主要反馈评审工件中的一些问题的个数、严重等级、分析和解决措施等。22，哪些工作进行了同行评审？答：《用户需求说明书》《软件需求说明书》《项目计划》《概要设计说明书》《详细设计说明书》《数据库设计说明书》《测试用例》23，同行评审收集了哪些数据？如何分析的？答：同行评审收集了评审工件中的问题个数、严重等级、产生的原因、解决措施，并记录在评审会议中。24，你们是如何确保的设计符合需求？答：我们利用《需求跟踪矩阵》来保证需求、设计、编码、测试的一致性和完整性；同时设计中的每一个阶段(概要设计阶段、详细设计阶段)都召开评审会议，确保阶段性工作产品的质量。25，产品集成的顺序和环境在哪里有记录？答：在《产品集成计划》中有记录26，项目是怎么发布的？谁来建立，评审和最终发布？答：由项目经理建立和发布项目产品，客户接收产品时，项目经理将《项目交付报告》交与客户签字。然后召开项目结项会议。27，项目在每个阶段是否都建立了基线？你们是如何得知基线的建立的？答：是的，当基线建立后，配置管理工程师向项目组成员发布基线报告。28，你们是如何参与项目计划和估算的？答：项目估算会议，根据开发经验对用户需求的功能点进行规模和工作量的估计，项目经理将每个专家的估计值进行计算，得到工作量和规模的平均值。然后参考财富库中的度量数据，进行项目的工作量估算。然后再估算出项目的成本。29，你们向谁做工作汇报，回报哪些内容？答：向项目经理汇报工作，汇报工作量，进度，偏差等。30，项目中有什么技术风险和问题？答：有人员的技术风险，也有项目管理的问题。31，如何保证代码质量？答：我们每天下班前，由项目经理组织开发人员进行交互代码走查，主要检查代码的编码规范和代码的逻辑性，并将发现的问题记录在《代码走查》中，同时开发人员进行单元测试，以保证代码的质量。32，你们是如何进行单元测试的？测试的结果会有记录吗？结果报告存放在那里？答：我们根据单元测试用例进行单元测试，采用白盒测试，测试结果记录在《测试记录跟踪表》中。33，如何确定编码结束的？答：1，项目经理已经确认，该软件的功能已经按照《用户需求说明书》和项目《软件需求说明书》的要求全部实现，功能和界面结合完成。2，所有功能代码均已基线化。3，单元测试，集成测试结束，系统预编译成功。4，该单元的项目《用户使用手册》、项目《系统安装手册》等相关文档必需提交到系统测试。34，项目中的源代码是如何管理的？答：我们使用的是git。35，你们是如何和测试人员合作的？答：首先，测试出的bug有四种状态，打开，跟踪，重新打开，关闭。当测试人员发现bug后，将bug记录在《测试记录跟踪表》中，此时的bug状态是打开；接着由测试人员将《测试记录跟踪表》提交给项目经理，由项目经理指定bug修改负责人，当bug修改负责人解决bug后，将bug的状态改为“跟踪”，然后提交给测试人员，由测试人员进行验证测试，当测试人员验证测试成功，则bug状态改为“关闭”，当测试人员验证测试失败后，则bug的状态改为“重新打开”，最为bug重新处理。36，编码过程中会统计哪些数据？这些数据存放在哪？答：在编码阶段，我们收集项目规模，数据都记录在《项目总结报告》中。37，项目经理是如何检查你们工作的？答：主要根据周会，里程碑会议来检查工作，同时在平时我们发现问题也会EMAIL或走查的形式通知项目经理，项目经理也会根据《项目进度表》监控我们的工作进展情况。38，你的项目是否有内部制定保证？答：有PPQA是根据QA制定的《检查表》在每个检查时机处检查我的工作，并将发现的NC通过EMAIL的形式发给我，我在接到NC一天内给予反馈。 以上是作为开发人员问的问题，测试人员没怎么问，就问了一道题，还是和开发人员重合的为35题。下午，第2，3个项目一起进入会议室访谈。 第三天上午他们在会议室对访谈内容进行分析，下午快下班时召开初步发现会议让我们对他们给出的访谈分析结果提出异议。 第四天上午，最终发布会议，全员都要参加。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS图片压缩]]></title>
      <url>%2F2016%2F09%2F03%2FiOS%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;在做iOS开发中，经常会遇到这样的问题，图片尺寸太大，或者文件体积太大，需要将图片压缩处理一下，然后上传服务器。&emsp;&emsp;当然，也不排除一些公司要求app上传原图，但是这种方式太耗流量且很耗时间，如果网络不佳，很容易上传失败，从而会失去一些用户。 1, 理解概念:1, “压” 是指文件体积变小，但是像素数不变，长宽尺寸不变，那么质量可能下降。2, “缩” 是指文件的尺寸变小，也就是像素数减少，而长宽尺寸变小，文件体积同样会减小。 2, 图片“压”处理:对于“压”功能，我们可以使用UIImageJPEGRepresentation或UIImagePNGRepresentation方法实现，如：1NSData *imgData = UIImageJPEGRepresentation(image, 0.5); 第一个参数是图片对象本身，第二个参数是压的系数，其值范围为(0-1);UIImageJPEGRepresentation的官方注释:The quality of the resulting JPEG image, expressed as a value from 0.0 to 1.0. The value 0.0 represents the maximum compression (or lowest quality) while the value 1.0 represents the least compression (or best quality).关于PNG和JPEG格式压缩:1. UIImageJPEGRepresentation函数需要两个参数:图片的引用和压缩系数而UIImagePNGRepresentation只需要图片引用作为参数.2.UIImagePNGRepresentation(UIImage *image)要比UIImageJPEGRepresentation(UIImage* image, 1.0)返回的图片数据量大很多项目中做图片上传之前，经过测试同一张拍照所得照片png大小在8M，而JPG压缩系数为0.75时候，大小只有1M。而且，将压缩系数降低对图片视觉上并没有太大的影响。友情提示：压缩系数不宜太低，通常是0.3~0.7，过小则可能会出现黑边等 3, 图片“缩”处理:主要通过 [image drawInRect:CGRectMake(0, 0, targetWidth, targetHeight)]; 实现。 12345678910111213141516171819202122232425262728293031323334353637/** * 1, 按图片最大边成比例缩放图片 * * @param image 图片 * @param maxSize 图片的较长那一边目标缩到的(宽度／高度) * * @return 等比缩放后的图片 */ - (UIImage *)scaleImage:(UIImage *)image maxSize:(CGFloat)maxSize &#123; NSData *data = UIImageJPEGRepresentation(image, 1.0); if(data.length &lt; 200 * 1024)&#123;//0.25M-0.5M(当图片小于此范围不压缩) return image; &#125; CGFloat imageWidth = image.size.width; CGFloat imageHeight = image.size.height; CGFloat targetWidth = imageWidth; CGFloat targetHeight = imageHeight; CGFloat imageMaxSize = MAX(imageWidth, imageHeight); if (imageMaxSize &gt; maxSize) &#123; CGFloat scale = 0; if (imageWidth &gt;= imageHeight) &#123;// 宽长 scale = maxSize / imageWidth; targetWidth = maxSize; targetHeight = imageHeight * scale; &#125; else &#123; // 高长 scale = maxSize / imageHeight; targetHeight = maxSize; targetWidth = imageWidth * scale; &#125; UIGraphicsBeginImageContext(CGSizeMake(targetWidth, targetHeight)); [image drawInRect:CGRectMake(0, 0, targetWidth, targetHeight)]; UIImage *scaledImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return scaledImage; &#125; return image;&#125; 12345678910111213141516/** * 2, 图片支持等比缩放 * * @param image 图片 * @param maxSize 缩放比例(通常0～1之间) * * @return 等比缩放后的图片 */- (UIImage *)scaleImage:(UIImage *)image toScale:(float)scaleSize &#123; UIGraphicsBeginImageContext(CGSizeMake(image.size.width *scaleSize, image.size.height * scaleSize)); [image drawInRect:CGRectMake(0, 0, image.size.width * scaleSize, image.size.height * scaleSize)]; UIImage *scaledImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return scaledImage;&#125; 123456789101112131415/** * 3, 等比缩放成自定长宽的图片 * * @param image 源图片 * @param targetSize 自定义目标图片的size * * @return 处理后图片 */- (UIImage *)scaleImage:(UIImage *)image toSize:(CGSize)targetSize &#123; UIGraphicsBeginImageContext(CGSizeMake(targetSize.width, targetSize.height)); [image drawInRect:CGRectMake(0, 0, targetSize.width, targetSize.height)]; UIImage *targetSizeImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return targetSizeImage;&#125; 我们对图片只“压”而不缩，有时候是达不到我们的需求的。因此，适当地对图片“缩“一下尺寸，就可以满足我们的需求。1234567891011121314//根据图片附获取图片大小(多少M)方法- (NSData *)imageData:(UIImage *)image &#123; NSData *data = UIImageJPEGRepresentation(image, 1.0); if (data.length &gt; 100*1024) &#123; if (data.length &gt; 1024*1024) &#123;//1M以及以上 data = UIImageJPEGRepresentation(image, 0.1); &#125; else if (data.length &gt; 512*1024) &#123;//0.5M-1M data = UIImageJPEGRepresentation(image, 0.5); &#125; else if (data.length &gt; 200*1024) &#123;//0.25M-0.5M data = UIImageJPEGRepresentation(image, 0.9); &#125; &#125; return data;&#125; 验证：以模拟器第二张绿叶图片为例原图大小为24.9M, 4288 * 2848像素；经一次UIImageJPEGRepresentation“压“处理12UIImage *tmpImage = [UIImage imageWithContentsOfFile:photo.photoPath];NSData *imageData = UIImageJPEGRepresentation(tmpImage, 0.5); 图片大小为836.9K, 4288 * 2848像素； 经一次UIImagePNGRepresentation“压“处理12UIImage *tmpImage = [UIImage imageWithContentsOfFile:photo.photoPath]; NSData *imageData = UIImagePNGRepresentation(tmpImage); 图片大小为24.9M, 4288 * 2848像素；几乎没变 经一次“缩“处理(笔者给予图片最大的宽度限定为640像素)12UIImage *tmpImage = [UIImage imageWithContentsOfFile:photo.photoPath];tmpImage = [self scaleImage:tmpImage maxSize:640]; 图片大小为795.9K, 640 * 426像素； 经一次“压缩”处理:123UIImage *tmpImage = [UIImage imageWithContentsOfFile:photo.photoPath];tmpImage = [self scaleImage:tmpImage maxSize:640]; NSData *imageData = UIImageJPEGRepresentation(tmpImage, 0.5); 图片大小为698K, 640 * 426像素；大家可以根据实际调整不同参数以达到自己的项目要求。]]></content>
    </entry>

    
  
  
</search>
