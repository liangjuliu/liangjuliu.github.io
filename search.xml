<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内存泄漏检测]]></title>
    <url>%2F2018%2F04%2F20%2FiOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F201804%2F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[首先要明确下基本定义，什么叫内存泄漏？ 内存泄漏(memory leak) ：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。 内存溢出(out of memory) ：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。通俗理解就是内存不够，通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。 排查方法静态分析通过Xcode打开项目，然后点击product -&gt; Analyze 分析， 静态分析方法能发现大部分的问题，但是只能是静态分析结果，有一些并不准确，还有一些动态分配内存的情形并没有进行分析。所以仅仅使用静态内存泄漏分析得到的结果并不是非常可靠，如果需要，我们需要将对项目进行更为完善的内存泄漏分析和排查。那就需要用到我们下面要介绍的动态内存泄漏分析方法Instruments中的Leaks方法进行排查。 动态分析静态分析不能把所有的内存泄露排查出来，有的内存泄露是在运行时，用户操作时才产生的。那就需要用到Instruments了。具体操作是通过xcode打开项目，然后点击product–&gt;profile。 dealloc分析通过在dealloc打印，来确定当前类是否被释放 借助于第三方库检测借助于第三方库检测，如 FBRetainCycleDetector 、 OOMDetector 等 常见内存泄漏原因 ViewController 中存在NSTimer ViewController 中的代理delegate ViewController 中Block ViewController 的子视图对self的持有 ViewController 之间的循环引用]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇：工具篇]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%2F201804%2F%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%2F</url>
    <content type="text"><![CDATA[工具篇&nbsp;&nbsp;上周去上海出差，被工行的人问到了解过代码混淆技术没，因为他们对安全性比较高，所以想对代码做下混淆，我一听，这不是安全攻防方面的知识吗，我做iOS开发也没接触过这方面的知识啊，所以回来赶紧上网查找资料，进行学习，也算是给无所事事的自己找点事做。 一开始以为做安全攻防必须需要一台越狱的手机设备，后来查找了很多资料，发现我错了，先说下学习环境吧： 环境: Xcode 9.3 IDA7.0 hex fiend(16进制编辑器) 硬件设备 iPhone7(建议5s以上设备，5和5c以下为arm32位版本，5s以后为64位版本) 以上工具下载链接: https://pan.baidu.com/s/1ZWHKt3kai9OtdeYntzPlOA 密码: iiwh 里面各个工具的作用不再详细阐述：IDA Proios-app-signer-master 重签名使用 &nbsp;&nbsp;在查找工具的过程中，偶然发现了一个非越狱插件开发集成神器！MonkeyDev 集成简单，堪称是一个神器。 Cycript 安装&nbsp;&nbsp;Cycript是一款脚本语言，可以看作是Objective-JavaScript，它可以帮助我们轻松测试和验证函数效果。 它的安装有多种方式 使用apt-get安装： apt-get install cycript 通过官网下载 SDK 安装 以下主要讲解通过第二种方式安装及可能遇到的问题： 在官网将cycript下载到本地，然后解压得到 cycript_0.9.594 文件夹(cycript_0.9.594为当前我可下载的最新版本) 打开终端 输入 cd / 进入根目录，再输入 la 查看当前目录下的所有文件，会发现一个opt文件夹，下一步打开这个文件夹 open opt 将刚才解压后的 cycript_0.9.594 文件夹 copy 到 opt 文件夹下 配置环境变量进入终端，编辑.base_profile文件 1$ vim ~/.bash_profile 123# Cycriptexport CY_PATH_ROOT=/opt/cycript_0.9.594export PATH=$CY_PATH_ROOT:$PATH 加入到 .base_profile中点击 esc 退出编辑模式，输入：+ wq!，保存退出。 立即更新刚才修改的环境变量1$ source .bash_profile 如果使用oh my zsh，在.zshrc配置文件中也加入刚才配置的环境变量路径，这样每次打开就不用手动执行了！ 大功告成，咱们照着官网的的命令操作一次，在终端中输入cycript，如果出现 环境配置成功。输入 control + D 即可退出 Cycript。 有时候结果并不像我们想的那么顺利， 123dyld: Library not loaded: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylibReferenced from: /Users/liangju/Downloads/cycript_0.9.594/Cycript.lib/cycript-aplReason: image not found 经过上网查证，报错原因竟然是因为ruby版本太高 本着出现问题就得解决的原则： 1.先查看下本地ruby版本1$ ruby -v 结果：ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin17] 果然是版本太高，Cycript需要依赖 ruby 2.0.0版本，这时就想着怎么解决，要不然再装个 ruby 2.0.0的版本，用它装完 Cycript 我再把 ruby 版本改为 2.5.1，这么感觉不好，太麻烦。 2.直接把本机的ruby版本的复制一份，改为2.0即可 既然 Cycript仅依赖ruby 2.0.0，那我直接把本机的ruby版本的复制一份，改为2.0不就可以了 12sudo mkdir -p /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/sudo ln -s /System/Library/Frameworks/Ruby.framework/Versions/2.5/usr/lib/libruby.2.5.1.dylib /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib 注：根据每个人ruby版本不同，将上面第二条命令的/System/Library/Frameworks/Ruby.framework/Versions/2.5.1/usr/lib/libruby.2.5.1.dylib中的2.5.1改成本机的ruby版本。 又遇到困难了，终端提示我没权限，不能操作。原来是系统的SIP搞得鬼。 3.关闭系统的SIP在 OS X El Capitan 中有一个跟安全相关的模式叫 SIP（System Integrity Protection ），它禁止让软件以 root 身份来在 Mac 上运行，在升级到 OS X 10.11 中或许你就会看到部分应用程序被禁用了，这些或许是你通过终端或者第三方软件源安装。 现在我们来关闭它： 电脑重启，听到咚的时候，按住command+R，进入恢复模式 打开终端，输入csrutil disable，重启即可，然后重复步骤2.把本机的ruby版本的复制一份，改为2.0，然后再在终端运行 如果想打开SIP，重复上两步，命令改为csrutil enable 现在再执行下cycript,终于大功告成。 &nbsp;&nbsp;下一篇，正式进入安全攻防内容，敬请期待。]]></content>
      <categories>
        <category>安全攻防</category>
      </categories>
      <tags>
        <tag>安全攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题目7:重建二叉树]]></title>
    <url>%2F2018%2F04%2F18%2F%E5%89%91%E6%8C%87offer%2F201804%2F%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8} 和 中序遍历序列 {4,7,2,1,5,3,8,6} ，则重建出如下图所示的二叉树并输出它的头结点。]]></content>
      <categories>
        <category>剑指Offer学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题目6:从尾到头打印链表]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%89%91%E6%8C%87offer%2F201804%2F%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[从尾到头打印链表输入一个链表的头节点，从尾到头反过来打印每个节点的值，链表节点定义如下： 12345678910/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;*/ 12345678910111213141516171819import java.util.ArrayList;import java.util.Stack; public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (listNode != null) &#123; stack.push(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!stack.isEmpty()) &#123; list.add(stack.pop()); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>剑指Offer学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题目5:替换空格]]></title>
    <url>%2F2018%2F04%2F16%2F%E5%89%91%E6%8C%87offer%2F201804%2F%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[替换空格题目：请实现一个函数，把字符串中的每个空格替换成”%20”。例如，输入”We are happy.”，则输出”We%20are%20happy.”。 12345678910111213141516171819202122232425262728293031public static void replaceSpace(char[] string) &#123; if (string.length &lt;= 0) &#123; return; &#125; int originalLength = string.length; int spaceCount = 0; for (int i = 0; i &lt; originalLength; i++) &#123; if (string[i] == ' ') &#123; spaceCount++; &#125; &#125; int newLength = originalLength + 2 * spaceCount; char[] tmpChar = new char[newLength]; int indexOfOriginal = originalLength - 1; int indexOfNew = newLength - 1; while (indexOfOriginal &gt;= 0) &#123; if (string[indexOfOriginal] == ' ') &#123; tmpChar[indexOfNew--] = '0'; tmpChar[indexOfNew--] = '2'; tmpChar[indexOfNew--] = '%'; &#125; else &#123; tmpChar[indexOfNew--] = string[indexOfOriginal]; &#125; indexOfOriginal--; &#125; &#125;]]></content>
      <categories>
        <category>剑指Offer学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题目3:数组中重复的数字]]></title>
    <url>%2F2018%2F04%2F05%2F%E5%89%91%E6%8C%87offer%2F201804%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[找出数组中重复的数字在一个长度为n的数组里的所有数字都在n～n-1范围内，数组中的某个数字是重复的，但是不知道有几个数字重复了，也不知道每个数字重复了几次，请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3},那么对应的输出是重复的数字2或者数字3。 123456789101112131415161718192021222324public static boolean dumplicate(int[] numbers) &#123; int len = numbers.length; if (len == 0) &#123; return false; &#125; for (int i = 0; i &lt; len; i++) &#123; if (numbers[i] &lt; 0 || numbers[i] &gt; len - 1) &#123; return false; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; while (numbers[i] != i) &#123; if (numbers[i] == numbers[numbers[i]]) &#123; return true; &#125; int tmp = numbers[i]; numbers[i] = numbers[tmp]; numbers[tmp] = tmp; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>剑指Offer学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 学习点滴记载(一)]]></title>
    <url>%2F2018%2F03%2F05%2FSwift%E5%AD%A6%E4%B9%A0%E7%82%B9%E6%BB%B4%E8%AE%B0%E8%BD%BD(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Swift设置导航栏(navigationBar)背景颜色,标题颜色和字体大小,item颜色12345678910111213141516func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. window = UIWindow(frame: UIScreen.main.bounds) window?.backgroundColor = UIColor.white let nav = UINavigationController(rootViewController: HomeVC()) //设置导航栏背景颜色 nav.navigationBar.barTintColor = UIColor.blue let dict:NSDictionary = [NSAttributedStringKey.foregroundColor: UIColor.white,NSAttributedStringKey.font : UIFont.boldSystemFont(ofSize: 18)] //标题颜色 nav.navigationBar.titleTextAttributes = dict as? [NSAttributedStringKey : AnyObject] //item颜色 nav.navigationBar.tintColor = UIColor.gray window?.rootViewController = nav window?.makeKeyAndVisible() return true&#125; Swift按钮传参数方法定义123456789101112131415161718192021222324 func initLeftAndRightBarItem() &#123;// let button = UIButton(frame: CGRect(x: 100, y: 200, width: 100, height: 100))// button.addTarget(self, action: #selector(obclick(sender:)), for: .touchUpInside)// button.backgroundColor = UIColor.red// self.view.addSubview(button) let leftBarBtnItem = UIBarButtonItem(image: UIImage.init(named: "tab_write"), style: .done, target: self, action: #selector(leftBtnClick(leftBarItem:))) let rightBarBtnItem = UIBarButtonItem(image: UIImage.init(named:"actionsheet"), style: .done, target: self, action: #selector(rightBtnClick(rightBarItem:))) self.navigationItem.leftBarButtonItem = leftBarBtnItem self.navigationItem.rightBarButtonItem = rightBarBtnItem &#125; // @objc func obclick(sender:UIButton) &#123;// print(#function)// print("asdasdasd")// &#125; @objc func leftBtnClick(leftBarItem: UIBarButtonItem) &#123; &#125; @objc func rightBtnClick(rightBarItem: UIBarButtonItem) &#123; &#125; Swift 中懒加载定义 tableView 两种不同的方法1lazy var homeTableView = UITableView(frame: CGRect(x: 0, y: kNavHeight, width: kScreenWidth, height: kScreenHeight), style: .plain) 123lazy var secondTableView = &#123; return UITableView(frame: CGRect(x: 0, y: kNavHeight, width: kScreenWidth, height: kScreenHeight), style: .plain) &#125;()]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础知识点总结(二)]]></title>
    <url>%2F2018%2F02%2F23%2FiOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F201802%2FiOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[1、请简单说明多线程技术的优点和缺点？优点 能够适当提高程序的执行效率； 能够适当的提高资源的利用率，比如CPU、内存。 缺点 创建线程有额外开销 程序的代码更加复杂 线程越多，CPU在调度线程上的开销就越大 如果开启大量线程，反而会降低程序的性能 2、请简单介绍下什么是原子和非原子属性？ atomic：原子属性，会为setter方法加锁，默认为atomic。线程安全，会消耗大量资源 nonatomic：非原子属性，不会为setter方法加锁。非线程安全，适合内存小的移动设备。 3、请简单说明对图片进行二级缓存的实现思路？在显示图片的时候 1.先检查该图片对应的内存缓存 1.如果存在内存缓存，则 a.直接使用设置并显示图片； 2.如果内存缓存中没有,则a.继续检查该图片对应的磁盘缓存是否存在，跳转到第2步。 2.检查该图片对应的磁盘缓存 1.如果存在磁盘缓存，则a.先保存一份到内存缓存中（方便下次使用）b.然后设置并显示图片 2.如果不存在磁盘缓存，则直接下载该图片，下载完成后a.保存一份到内存缓存中b.保存一份到磁盘缓存中c.设置并显示图片 4、请简单说明NSCache的特点？ NSCache是苹果推出专门用来处理内存缓存的类 NSCache默认是线程安全的,在使用的时候可以不用考虑线程安全的问题 NSCache使用方法和可变字典类似,当缓存文件超过最大限度的时候会开启一个回收过程,把最老的缓存对象回收 NSCache可以设置缓存的const(成本)和缓存的数量 5、请问SDWebImage框架的框架结构是怎么样的？SDWebImage框架有几个主要的组件： 管理者（SDWebImageManager) 缓存处理组件（SDImageCache）主要对下载的图片进行内存缓存和磁盘缓存处理 下载处理组件（SDWebImageDownloader|SDWebImageDownloadOperation）主要处理开子线程异步发送网络请求下载图片相关操作 6、请简单说明GET请求和POST个请求有什么区别,如何选择？ GET请求的参数直接用&amp;拼接并以？为分隔拼接在请求URL的后面 POST请求的参数是转换为二进制设置在请求体传递的 如果仅仅只是索取数据获得数据，那么建议使用GET请求，其他情况则建议使用POST请求，相对而言POST请求安全性更好一些。 7、请简单列出使用NSURLConnection发送一个异步POST网络请求的步骤? 1.确定请求路径（URL） 2.创建可变的请求对象（NSMutableURLRequest） 3.修改请求方法为POST请求 4.把参数拼接起来转换为二进制数据，设置请求体 5.使用NSURLConnection发送异步请求([NSURLConnection sendAsync….]) 6.解析服务器返回的数据，查看请求结果 8、请简单介绍下AFN各个主要版本的情况？1234560.1--1.0 "2.0---2.6.3" 3.0--&gt;3.1.0NSURLConnection - (NSURLConnection + NSURLSession) - NSURLSession0.1-2.0 NSURLConnection2.0 -3.0 NSURLSession + NSURLConnection3.0 + NSURLSession 9、在使用NSURLSession进行文件上传的时候，如何监听文件上传的进度，有哪些注意点？ 创建会话对象的时候，需要设置代理，让控制器成为session的代理 遵守代理协议（NSURLSessionDataDelegate） 实现代理方法，在代理方法中计算文件的上传进度12345 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend 注意：当任务执行完毕的时候应该释放对代理对象的强引用 10、在发送网络请求的时候，如果一个参数（place）需要对应着多个值，那么以下两种请求路径哪种是正确的？123①:[http://192.168.31.520:1314/loveyou?place=Beijing&amp;Shanghai](http://120.25.226.186:32812/weather?place=Beijing&amp;Shanghai)②:[http://](http://120.25.226.186:32812/weather?place=Beijing&amp;place=Shanghai)[192.168.31.520:1314](http://120.25.226.186:32812/weather?place=Beijing&amp;Shanghai)/loveyou?place=Beijing&amp;place=Shanghai 第二种请求路径是正确的，第一种是错误的，后面的shanghai将会被忽略]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础知识点总结(一)]]></title>
    <url>%2F2018%2F02%2F05%2FiOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F201802%2FiOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[以下是一些自己收集的比较基础的面试问题（大神可以忽略）附上答案，毕竟个人水平有限难免会有些错误或回答的局限性，如果发现错误也欢迎大家指出，一起探讨进步。 1、#import和#include的区别,@class代表什么 import会包含这个类的所有信息，包含实体变量和方法(.h文件中)，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，后面会再告诉你。 #import比起#include的好处是不会引起交叉编译，也就是常说的重复包含。 注：#import 就是把被引用类的头文件都走一遍，即把.h文件里的变量和方法都包含进来一次，且仅一次，而@class不用，所以后者编译效率更高。 2、控制器的生命周期 initWithCoder:(NSCoder *)aDecoder：（如果使用storyboard或者xib） loadView：加载view viewDidLoad：view加载完毕 viewWillAppear：控制器的view将要显示 viewWillLayoutSubviews：控制器的view将要布局子控件 viewDidLayoutSubviews：控制器的view布局子控件完成这期间系统可能会多次调用viewWillLayoutSubviews 、 viewDidLayoutSubviews viewDidAppear：控制器的view完全显示 viewWillDisappear：控制器的view即将消失 viewDidDisappear：控制器的view完全消失 loadView方法: 当我们用到控制器view的时候，就会调用控制器view的get方法，在get方法内部，首先判断view是否已经被创建，如果已经存在，则直接返回存在的view，如果不存在，则会调用控制器的loadView方法，在控制器没有被销毁的情况下，loadView也可能会被执行多次小结：控制器view的生命周期：loadView -&gt; viewDidLoad -&gt; viewWillAppear -&gt; viewWillLayoutSubviews -&gt; viewDidLayoutSubviews-&gt; viewDidAppear -&gt; viewWillDisappear -&gt; viewDidDisappear 3、导航push做了哪些事情 当调用push方法时, 会把要push的控制器添加到导航控制器管理的栈中,把之前导航控制器中栈顶控制器View给移除,把当前栈顶控制器添加上去 4、导航pop做了哪些事情 当调用pop方法的时候，会把要pop的控制器从栈里移除，把之前导航控制器中栈顶控制器的view移除，把当前栈顶控制器添加上去 5、frame 和 bounds 的区别是什么？ frame相对于父视图,是父视图坐标系下的位置和大小。bounds相对于自身,是自身坐标系下的位置和大小。 frame以父控件的左上角为坐标原点，bounds以自身的左上角为坐标原点 6、+load 和 +initialize 的区别是什么 +(void)load;&emsp;当类对象被引入到项目时，runtime会向每个一个类对象发送load消息，load方法会在每一个类甚至分类被引入时仅调用一次，调用的顺序：父类优先于子类，子类优先于分类 +(void)initialize;&emsp;第一次使用这个类的时候会调用这个方法 7、如何为Class定义一个对外只读对内可读写的属性 在头文件中将属性定义为readonly，在.m文件中将属性重新定义为readwrite 8、strong / weak / unsafe_unretained的区别 weak只能修饰OC对象，使用weak不会使引用计数加1，对象销毁时修饰的对象会指向nil strong等价于retain，能使计数器加1，且不能用来修饰数据类型 unsafe_unretained等价于assign，可以用来修饰数据类型和OC对象，但是不会使计数器加1，且对象销毁时也不会将对象指向nil，容易造成野指针错误。 9、iOS 的沙盒目录结构是怎样的 Application:存放程序源文件，上架前经过数字签名，上架后不可修改 Documents:常用目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。 Library Caches：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。 Preference：iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好. tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。该路径下的文件不会被iTunes备份。 10、通过代码如何自定义控件? 并且简单的描述下每一个步骤的理由? 新建一个继承UIView的子类(所谓自定义控件就是继承系统自带的控件写一个适合自己项目特殊需求的控件) 在initWithFrame方法中添加子控件(保证别人在其他类不管是通过init还是通过initWithFrame创建都能够添加子控件，因为init方法内部会调用initWithFrame) 在layoutSubViews方法中设置子控件的frame(在initWithFrame方法中当前的控件可能没值，所以计算不了子控件的位置和尺寸，而在layoutSubViews方法中，能够拿到当前控件的尺寸) 提供一个模型属性，重写模型属性的set方法 11、简单的描述下类扩展(extension)和分类(category)的区别? 类扩展(也被称作匿名分类)没有名字，分类有名字 类扩展中新添加的方法必须要实现，分类可以不实现 类扩展是分类的一个特例，可以为一个类添加一些私有成员变量和方法，分类可以在不修改原来类的基础上，为一个类添加类扩展方法，一般用于给系统自带的类扩展方法，不能添加成员变量，如果一定要添加，可以通过runtime实现 12、Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能 主要考察的是runtime如何交换方法 实现：1，先在分类中添加一个方法，注意不能重写系统方法，否则会被覆盖 123+ (NSString *)p_printLog &#123; // 这里写打印行号,什么方法,哪个类调用等等&#125; 2，交换方法123456789// 加载分类到内存到时候调用+ (void)load &#123; // 获取系统的描述方法 Method description = class_getClassMethod(self, @selector(description)); // 自定义的打印日志方法 Method myLog = class_getClassMethod(self, @selector(p_printLog)); // 交换方法 method_exchangeImplementations(description, myLog);&#125; 13、如何让 Category 支持属性 使用runtime实现 12345678910111213141516171819202122// .h@interface NSObject (LJTest)@property (nonatomic, copy) NSString *testName;@end// .mstatic const char *kIdentifier = "testName";@implementation NSObject (LJTest)- (NSString *)testName &#123; // 根据关联的 kIdentifier, 获取关联的值 return objc_getAssociatedObject(self, kIdentifier);&#125;- (void)setTestName:(NSString *)testName &#123; // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, kIdentifier, testName, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125; 14、iOS assign，weak，strong，copy， atomic， nonatomic 使用场景assign 与 weak区别 assign 适用于基本数据类型，weak适用于NSObject对象，并且是一个弱引用，assign其实也可以用来修饰对象，那么我们为什么不用它修饰对象呢？因为被assign修饰的对象(一般编译的时候会产生警告：Assigning retained object to unsafe property; object will be released after assignment)在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil，造成野指针，对象一般分配在堆上的某块内存内存上，如果在后续的内存分配中，恰巧分到了这块地址，程序就会崩掉 为什么可以用assign修饰基本数据类型呢？因为基础数据类型一般分配在栈上，栈的内存会由系统自动处理，不会造成野指针。weak修饰的对象在释放之后，指针地址会被置为nil，所以在一般弱引用使用weak修饰 weak使用场景：在ARC，在有可能出现循环引用的时候，往往要通过让其中的一端使用weak来解决，常见的比如：delegate属性，通常就会声明为weak。自身已经对它进行一次强引用，没有必要再强引用一次时也会使用weak。 strong 与 copy区别 strong与copy都会使引用计数(retain)加1，但strong是两个指针指向同一块地址，copy会在内存里拷贝一份对象，两个指针指向不同的内存地址 block 与 weak区别 __block用来修饰一个变量，这个变量在block代码块中，如果想被修改，则需要使用__block修饰，使用使用 __block修饰的变量在block代码块中会被retain（ARC下会retain，MRC下不会retain）weak：使用weak修饰的变量不会在block代码块中被retain，同时，在ARC下，要避免block出现循环引用 __weak typedof(self)weakSelf = self; nonatomic 与 atomic区别 atomic的意思就是setter/getter这两个函数的一个原语操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样。 nonatomic不保证setter/getter的原语行，所以你可能会取到不完整的东西。 比如setter函数里面改变两个成员变量，如果你用nonatomic的话，getter可能会取到只更改了其中一个变量时候的状态。 atomic是线程安全的,nonatomic是线程不安全的。如果只是单线程操作的话用nonatomic最好,因为后者效率高一些 15、对NSUserDefaults的理解 NSUserDefaults是系统提供的一种存储数据的方式，主要用于保存少量的数据，默认存储到library下的Preferences文件夹 16、LoadView 作用以及使用LoadView的注意点?控制器调用loadView方法创建控制器的view.它默认的做法是： 先去判断当前控制器是不是从StoryBoard当中加载的，如果是，那么他就会从StoryBoard当中加载控制器的View. 如果不是从StoryBoard当中加载的，那么他会从Xib加载控制器的View. 如果也不是从Xib加载的控制器，那么他就会创建一个空的UIView，设为当前控制器的View.注意： 一旦重写了loadView，表示需要自己创建控制器的View。 如果控制器的View还没有赋值，就不能调用控制器的View的get方法，会造成死循环，因为控制器View的个体方法底层会调用loadView方法. 最后附pdf版本查看链接：iOS基础知识点总结(一).pdf]]></content>
      <categories>
        <category>iOS基础</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS多工程依赖]]></title>
    <url>%2F2016%2F12%2F25%2FiOS%E5%A4%9A%E5%B7%A5%E7%A8%8B%E4%BE%9D%E8%B5%96%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在日常开发中，有时候我们为了保持整个项目的结构清晰，需要对项目的不同的类进行模块化，其中使用工程依赖是个不错的选择。 准备工作1，新建一个workspace工程，我创建了一个TestDemo工程然后引入cocoapods.2，然后新建一个静态库工程，建立方法Framework &amp; Library-&gt;Cocoa Touch Static Library取名为LJCommonUI，注意：这个静态库工程与第一个工程分开创建3，将LJCommonUI拖进基础工程的文件夹 建立相关引用1，打开基础工程，Add Files to…，把LJCommonUI引入添加完如下图2，设置Header Path, Build Setting-Header Search Paths (添加头文件搜索路径)3，引入.a文件, Build Phases - Link Binary With Libraries 添加LJCommonUI.a注意：1，如果LJCommonUI里面有图片或者其他的依赖库B-Build Phases - Copy Files添加对应的图片和依赖库2，如果LJCommonUI里有category，使用category的时候会crashB-Other Linker Flags 添加-Objc和-all_load确保category被正常引入 打包注意事项有依赖库的时候，Archive通常在organize里找不到项目或者没有version和identifier要把依赖库LJCommonUI - Build Settings - Skip Install设置为YES，但项目TestDemo - Skip Install设置为NO]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS文件统一管理]]></title>
    <url>%2F2016%2F12%2F10%2FiOS%E6%96%87%E4%BB%B6%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在做我们公司自己的项目时，遇到了一个难题，就是随着用户使用我们公司的app时间越久，便导致app沙盒文件越来越多，严重时我查看我们公司的app使用内存量达到了7.3G，查看方式，打开你的苹果手机,(设置-通用-储存空间及iCloud用量-管理储存空间);怎么样不查不知道一查是不是吓一跳？&emsp;&emsp;细说下我们公司app占用内存量大的原因，我们公司的app属于类社交和OA类，其中有类似微信的朋友圈和聊天，及收藏功能，所以当用户发图片很多时，图片都存入自己的沙盒中，当用户在聊天页面点击图片收藏，图片会复制一份并生成新的图片再次上传服务器，同时新生成的图片也会copy到我们已经规定好的沙盒中的收藏文件夹(之所以给每个模块都在沙盒目录中规定一个文件夹，为了便于清理,注：每个聊天会话的图片都存在它特定的文件夹下，删除某一条会话时，会话下的图片也能得到及时清除)下。同理，在朋友圈中的图片也可以收藏。所以当图片少的时候暂时没有发现问题，而且似乎感觉还很好，因为每次文件清理直接拿到每一个模块的路径文件夹清理就可以。然而，随着时间的推移，用户选择的文件的越来越多，便产生一开始描述的问题。附路径地址：/Users/liangju/Library/Developer/CoreSimulator/Devices/6184D61E-A799-4127-881E-F71E3D9CD61B/data/Containers/Data/Application/F83F1BC6-4809-40B9-80EC-D1EC7FEF2FBA/Documents/my_app/1BdWrWKyJ8MUpM7ofJsa4g/file/CC_OPEN_MESSAGE/g_2BwfR0iZJedUvP6ispaOAp/168D8A9C8830461AAC6C6711C9136115.jpg /Users/liangju/Library/Developer/CoreSimulator/Devices/6184D61E-A799-4127-881E-F71E3D9CD61B/data/Containers/Data/Application/F83F1BC6-4809-40B9-80EC-D1EC7FEF2FBA/Documents/my_app/1BdWrWKyJ8MUpM7ofJsa4g/file/CC_OPEN_MESSAGE/ u_2aRr2i4UF5dkXExQMVTly1I/317C7D7B10D847B09F4CE827BC8EB78F.jpg其中地址中my_app 为app名字，1BdWrWKyJ8MUpM7ofJsa4g为登录人id，CC_OPEN_MESSAGE为服务id，也就是下文中的SERV_ID，u_2aRr2i4UF5dkXExQMVTly1I为绘画id，其中我们公司规定以u开头是单人绘画，g开头为群组绘画，同时此项也就是下文中的DATA_ID，再往下就是image对象名字了&emsp;&emsp;所以便想能不能把这些文件统一管理起来，比如聊天中的图片再收藏时(前提此图片已经上传服务器成功，上传失败的情况我们稍后讨论)，能不能不在复制产生新的图片上传，收藏模块的图片直接去聊天的那张图片路径下，把这张图片读出显示。&emsp;&emsp;实现篇:统一封住文件最终下载所调的接口。每个文件下载时都给它固定了一个下载路径。当它下载成功后，把文件对应的服务器的文件id，保存到数据表中。结合每个公司的不同情况合理设置缓存模型，我们公司的设置如下： 1234567891011121314151617181920// 文件在服务端的id @property (nonatomic, copy) NSString *SERVER_FILEID;// 功能分类:例如：在聊天中就是CC_OPEN_MESSAGE@property (nonatomic, copy) NSString *SERV_ID;// 在chat功能中就是msgId@property (nonatomic, copy) NSString *DATA_ID;// 文件长度@property (nonatomic, copy) NSString *FILE_SIZE;// 待定：数据创建时间@property (nonatomic, copy) NSString *S_ATIME;// 待定：数据创建时间@property (nonatomic, copy) NSString *S_MTIME;// 本地相对路径@property (nonatomic, copy) NSString *PATH; 其次在每次下载图片的时候，1，先从sd内存缓存里读出图片，若读出直接block image对象；2，若不存在image，则需要先根据SERVER_FILEID查一下本地是否已经存在那条数据，如果存在，根据路径读出图片，再根据SERV_ID、DATA_ID、SERVER_FILEID再次查找本地表是否存在这条数据，如果不存在，则新建一条数据；当根据SERVER_FILEID在本地表中查找不到时，继续往下走，调用图片下载方法(我们采用的图片下载三方为sd),以下为相关代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687- (void)rh_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock rhImgParam:(RHImageParam *)rhImgParam &#123; //modify if (!url) &#123; return; &#125; NSDictionary *dict = [RHFileCacheHelper getServeFileIdAndImageSizeWithServerUrl:url]; NSString *fileId = dict[@"FIELD"]; NSString *image_size = dict[@"IMG_SIZE"]; NSDictionary *paramDict = rhImgParam.extraDict; NSString *serv_Id = paramDict ? paramDict[@"SERV_ID"] : @""; NSString *data_Id = paramDict ? paramDict[@"DATA_ID"] : @""; if (rhImgParam.category) &#123; url = [[RHWebImageManager sharedManager] changeURL:url param:rhImgParam]; &#125; // 0 表示未传值 (默认) if (options == 0 || ((options &amp; SDWebImageRefreshCached) != SDWebImageRefreshCached)) &#123; // 1，内存缓存读出图片 NSString *key = [rhImgParam.manager cacheKeyForURL:url]; UIImage *image = [rhImgParam.manager.imageCache imageFromDiskCacheForKey:key]; if (image) &#123; self.image = image; if (completedBlock) &#123; completedBlock(image, nil, SDImageCacheTypeMemory, url); &#125; return; &#125; else &#123; // 2，从缓存表中读出图片 if ([image_size integerValue] &gt; 300) &#123; image = [RHFileCacheHelper fetchSqlCacheImageWithServId:serv_Id dataId:data_Id serFileId:fileId]; if (image) &#123; // servId dataId servFileId self.image = image; if (completedBlock) &#123; completedBlock(image, nil, SDImageCacheTypeDisk, url); &#125; return; &#125; &#125; &#125; &#125; [self rh_cancelCurrentImageLoad]; objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC); if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; self.image = placeholder; &#125;); &#125; if (url) &#123; __weak __typeof(self)wself = self;// id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; id &lt;SDWebImageOperation&gt; operation = [rhImgParam.manager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (!wself) return; dispatch_main_sync_safe(^&#123; if (!wself) return; if (image) &#123; wself.image = image; [wself setNeedsLayout]; if (([image_size integerValue] &gt; 300) &amp;&amp; image) &#123; // 保存图片到缓表的操作 NSString *fileName = [RHTools cachedFileNameForKey:url.absoluteString param:rhImgParam]; NSString *fullPath = [RHCommonHelper getCacheFileFullPathWithServID:serv_Id dataId:data_Id imageId:fileName]; NSInteger length = [UIImageJPEGRepresentation(image,1) length]; RHFileCacheModel *fileModel = [RHFileCacheHelper getFileCacheModelWithServ_Id:serv_Id dataId:data_Id server_FileId:fileId fileLocalFullPath:fullPath fileSize:([NSString stringWithFormat:@"%ld", (long)length])]; [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel]; &#125; &#125; else &#123; if ((options &amp; SDWebImageDelayPlaceholder)) &#123; wself.image = placeholder; [wself setNeedsLayout]; &#125; &#125; if (completedBlock &amp;&amp; finished) &#123; completedBlock(image, error, cacheType, url); &#125; &#125;); &#125;]; [self sd_setImageLoadOperation:operation forKey:@"UIImageViewImageLoad"]; &#125; else &#123; dispatch_main_async_safe(^&#123; NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @"Trying to load a nil url"&#125;]; if (completedBlock) &#123; completedBlock(nil, error, SDImageCacheTypeNone, url); &#125; &#125;); &#125;&#125; 1234567891011121314151617181920212223242526272829/** * 根据servId、dataId，serFileId读出混存表中的图片 * @param servId 服务id * @param dataId dataid * @param serFileId 服务端文件id * @return image对象 */+ (UIImage *)fetchSqlCacheImageWithServId:(NSString *)servId dataId:(NSString *)dataId serFileId:(NSString *)serFileId &#123; NSArray *fileArray = [[RHFileCacheManager sharedInstance]fetchFileCacheFileWithServer_FileId:serFileId]; // 根据serFileId 查询缓存表并转换为缓存model读出 if (fileArray.count &gt; 0) &#123; RHFileCacheModel *fileModel = [fileArray firstObject]; // 缓存model NSString *path = [RHCommonHelper getFullPathWithRelativePath:fileModel.PATH]; // 获取图片的全路径 UIImage *image = [UIImage imageWithContentsOfFile:path]; if (image) &#123; // servId dataId servFileId NSArray *tmpArray = [[RHFileCacheManager sharedInstance]fetchFileCacheFileWithServId:servId dataId:dataId serverFileId:serFileId]; if (tmpArray.count == 0) &#123; fileModel.ID = [RHTools stringUUID]; // uuid 随机生成的数据 fileModel.S_ATIME = [RHDateTools currenTime]; fileModel.S_MTIME = [RHDateTools currenTime]; fileModel.SERV_ID = servId; fileModel.DATA_ID = dataId; fileModel.SERVER_FILEID = serFileId; [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel]; &#125; return image; &#125; &#125; return nil;&#125; 接下来我们来处理图片上传的情况：在上传图片接口；无论成功，失败都要将其结果保存数据库，只是失败时不存在SERVER_FILEID；其次在处理上传成功的图片，在其保存前先根据SERV_ID，DATA_ID，PATH查寻缓存表，看这条数据是否已经存在，若存在，只需更新表，把SERVER_FILEID更新至表中，若不存在，则生成一条新的数据保存至表中。 123456789101112131415161718192021/** 处理上传成功的图片 * @param servId 服务Id * @param dataId dataId * @param serverFileId 服务端文件Id * @param fullPath 全路径 * */+ (void)dealSuccessPhotosWithServId:(NSString *)servId dataId:(NSString *)dataId serverFileId:(NSString *)serverFileId fileLocalFullPath:(NSString *)fullPath &#123; if ([RHTools checkIfPreviewImage:serverFileId] &amp;&amp; [FCFileManager existsItemAtPath:fullPath]) &#123; // 根据serverFileId后缀名检查是否是图片，并且本地路径下是否存在该文件 NSArray *cacheOldArr = [[RHFileCacheManager sharedInstance]fetchFileCacheFileWithServId:servId dataId:dataId fullPath:fullPath]; RHFileCacheModel *fileModel = [[RHFileCacheModel alloc]init]; if (cacheOldArr.count == 0) &#123; // 缓存表中不存在这一条记录 fileModel = [self p_getFileCacheModelWithServId:servId dataId:dataId serverFileId:serverFileId fileLocalFullPath:fullPath]; // 生成缓存模型 &#125; else &#123; fileModel = [cacheOldArr firstObject]; fileModel.PATH = [RHCommonHelper getRelativePathWithfullPath:fullPath]; // 根据全路径获取相对路径 fileModel.SERVER_FILEID = serverFileId; &#125; [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel]; // 保存到缓存表&#125; 12345678910111213141516/** * 处理上传失败的图片数组 * @param servId 服务iId * @param dataId dataId * @param failures 失败数组 */+ (void)dealPostFailPhotosWithServId:(NSString *)servId dataId:(NSString *)dataId failures:(NSArray *)failures &#123; for (NSDictionary *content in failures) &#123; NSString *fullpath = content[@"fileURL"]; if ([FCFileManager existsItemAtPath:fullpath]) &#123; RHFileCacheModel *fileModel = [self p_getFileCacheModelWithServId:servId dataId:dataId serverFileId:@"" fileLocalFullPath:fullpath]; [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel]; &#125; &#125;&#125; &emsp;&emsp;删除逻辑:删除时首先根据SERVER_FILEID查表中数据，如果大于1，说明此文件被多个地方引用，不删除文件，仅根据SERV_ID，DATA_ID，SERVER_FILEID，删出表中这条数据；若根据SERVER_FILEID查表中数据等于1，删除文件，同时根据SERV_ID，DATA_ID，SERVER_FILEID，删出表中这条数据。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我曾经经历的CMMI3认证之关于软件开发人员的访谈]]></title>
    <url>%2F2016%2F10%2F29%2F%E6%88%91%E6%9B%BE%E7%BB%8F%E7%BB%8F%E5%8E%86%E7%9A%84CMMI3%E8%AE%A4%E8%AF%81%E4%B9%8B%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E8%AE%BF%E8%B0%88%2F</url>
    <content type="text"><![CDATA[自己所在的公司申请CMMI3等级认证，本人又有幸成为了被访谈中的一员，我由于本人从属于公司的研发部的一名研发人员，所以我的身份顺理成章的也是开发人员。主评官是一名德国老外。 当时我们公司和对方约定的访谈时间是10月18日~10月21日，第一天首先是发起人见面，然后要参加被访谈的全体人员参加启动会议，下午是分别是EPG组长、CM、OT、PPQA的访谈，开发人员是19号。 我们公司一共准备了3个项目(每个项目组配备两名开发人员，一名测试人员)，我是第一个项目组的成员，早晨9点钟到达公司，大概9:15左右，会议室的人出来叫人说可以开始了，让我们进去，进入到会议室之后老外先和我们打了招呼，然后翻译在旁翻译，并且讲述访谈的原则不归咎原则，及签订保密协议。 下面是我们访谈的被问到的问题：1，公司定义了哪些不同的需求获取的方式？答：公司定义的需求获取的方式有：电话、邮件、调查问卷、开研讨会、静态页面效果图、原型等方式2，你的项目中使用了哪些方式获取客户的需求的？获取了客户的哪些需求？答：邮件、调查问卷、开研讨会、静态页面效果图；获取了客户的需求分为功能性需求和质量属性方面的需求，质量属性方面的需求可分为可维护性，安全性，易用性等等。3，客户有没有对你们获取后的需求进行确认？如何确认的？答：我们将用户的需求整理，制定成《用户需求说明书》并交与客户确认签字。4，项目中的需求是如何进行管理的？答：我们在每个阶段完成时，都填写《需求跟踪矩阵》，所以当需求变更时，我们《需求跟踪矩阵》来查看每个需求的状态，了解因变更而影响的需求范围。5，你们是如何对客户的需求进行分析的？答：我们采用VISO工具来分析系统，并对系统进行建模，制定出系统的业务流程图和系统架构图，当《软件需求说明书》制定完成后，由项目经理组织邀请客户，开发人员，测试人员，配置人员，质量保证人员，高层参加软件需求说明书的评审会议，在保证需求分析是满足客户需求的，并得到大家的认可。6，需求的优先级和难易度是如何来定义的？答：我们是根据需求的难易度来确定优先级的。高 — 软件必须实现的功能，用户有明确的功能定义和要求；中 — 软件应该实现的功能，用户的功能定义和要求可能是模糊的、不具体的、或低约束的，但是这类功能的缺少会导致用户的不满意，因此这类功能的具体需求应当由需求分析人员诱导用户产生并明确；低 — 软件尽量实现的功能，并可根据开发进度进行取舍，但这类功能的实现将会增加用户的满意度。7，公司是如何跟踪项目的需求接口需求的？答：根据《用户需求说明书》指定的《软件需求说明书》中定义了软件的接口需求。并在《需求跟踪矩阵》中进行接口需求的跟踪。8，如何对需求进行管理来确保需求的完整性，一致性？答：通过评审会议，维护《需求跟踪矩阵》，以及周会确保需求的完整性和一致性。9，需求变更的时候由谁来确认？答：当需求变更的时候，由项目经理提交需求变更申请到CCB(变更控制委员会)进行确认是否变更。10，你们怎么确保不同工作产品的一致性和完整性？答：通过召开评审会议确保不同工作产品的一致性和完整性。11，对于过程改进活动，你们参与了哪些工作？答：参与了临时过程组对OSSP体系对编写，需求开发与管理，设计过程等。12，需求经验和优秀实践经验如何和其他项目和组织分享？答：一般有好的经验或建议，我们会向EPG反馈，EPG组长整理采纳后会存放在公司的财富库中。13，在过程规范中变更如何通知你们的？答：过程规范发生变更时，过程改进会形成新的基线，配置管理工程师会发布基线报告，EPG组长会安排相应人员给我们培训。14，如何管理产品交付后客户的需求？答：在产品交付客户后，我们给客户有1年的免费维护期，如果是原需求的变更，我们免费维护，如果新需求的变更，则另有偿维护。15，公司是否通过了设计方面的指南？答：是的，EPG制定了《设计过程》《实现过程》等来指导我们工作。16，设计过程是什么？答：项目经理指定角色，要先做《概要设计说明书》和《编码规范》，然后召开评审会议，评审通过后，再做《详细设计说明书》及《数据库设计说明书》，同时界面设计师做静态界面设计，然后由项目经理召开评审会议，评审通过后，将相关配置项由配置管理工程师入库等。17，设计采用了哪些技术？答：结构化设计方法：1，自顶向下 2，逐步细化 3，模块化设计 4，结构化编码结构化设计步骤如下：1，审核细化数据流2，确定数据流程图的类型3，把数据流图映射到软件模块结构，设计出模块结构的上层4，基于数据流图逐步分解高层模块，设计中下层模块5，对模块结构进行优化，得到更合理的软件结构6，描述模块接口18，目前的决策分析方法有哪些？答：主要采用了经验法和类比法两种。然后采用专家法打分决策19，项目中的重用组件使用前，项目组有没有进行讨论？答：在《项目计划》里定义并分析了项目重用组件，并在《项目计划》会议上，对项目的组件重用进行了分析讨论。20，设计阶段你们做了哪些评审，如何做的？答：设计阶段有《概要设计说明书》评审，《详细设计说明书》评审；《里程碑》等评审活动，在评审会议上，由主持人组织会议持续，作者讲解评审工作的内容，回答评审人员提出的问题，会议记录人员将会议上的内容及问题进行记录，并整理到《评审记录》中，由项目经理指定并监控负责人解决评审中发现的问题。21，关于这些评审，计划多少的工作量？评审的主要反馈是什么？答：评审会议一般持续4个小时左右，评审主要反馈评审工件中的一些问题的个数、严重等级、分析和解决措施等。22，哪些工作进行了同行评审？答：《用户需求说明书》《软件需求说明书》《项目计划》《概要设计说明书》《详细设计说明书》《数据库设计说明书》《测试用例》23，同行评审收集了哪些数据？如何分析的？答：同行评审收集了评审工件中的问题个数、严重等级、产生的原因、解决措施，并记录在评审会议中。24，你们是如何确保的设计符合需求？答：我们利用《需求跟踪矩阵》来保证需求、设计、编码、测试的一致性和完整性；同时设计中的每一个阶段(概要设计阶段、详细设计阶段)都召开评审会议，确保阶段性工作产品的质量。25，产品集成的顺序和环境在哪里有记录？答：在《产品集成计划》中有记录26，项目是怎么发布的？谁来建立，评审和最终发布？答：由项目经理建立和发布项目产品，客户接收产品时，项目经理将《项目交付报告》交与客户签字。然后召开项目结项会议。27，项目在每个阶段是否都建立了基线？你们是如何得知基线的建立的？答：是的，当基线建立后，配置管理工程师向项目组成员发布基线报告。28，你们是如何参与项目计划和估算的？答：项目估算会议，根据开发经验对用户需求的功能点进行规模和工作量的估计，项目经理将每个专家的估计值进行计算，得到工作量和规模的平均值。然后参考财富库中的度量数据，进行项目的工作量估算。然后再估算出项目的成本。29，你们向谁做工作汇报，回报哪些内容？答：向项目经理汇报工作，汇报工作量，进度，偏差等。30，项目中有什么技术风险和问题？答：有人员的技术风险，也有项目管理的问题。31，如何保证代码质量？答：我们每天下班前，由项目经理组织开发人员进行交互代码走查，主要检查代码的编码规范和代码的逻辑性，并将发现的问题记录在《代码走查》中，同时开发人员进行单元测试，以保证代码的质量。32，你们是如何进行单元测试的？测试的结果会有记录吗？结果报告存放在那里？答：我们根据单元测试用例进行单元测试，采用白盒测试，测试结果记录在《测试记录跟踪表》中。33，如何确定编码结束的？答：1，项目经理已经确认，该软件的功能已经按照《用户需求说明书》和项目《软件需求说明书》的要求全部实现，功能和界面结合完成。2，所有功能代码均已基线化。3，单元测试，集成测试结束，系统预编译成功。4，该单元的项目《用户使用手册》、项目《系统安装手册》等相关文档必需提交到系统测试。34，项目中的源代码是如何管理的？答：我们使用的是git。35，你们是如何和测试人员合作的？答：首先，测试出的bug有四种状态，打开，跟踪，重新打开，关闭。当测试人员发现bug后，将bug记录在《测试记录跟踪表》中，此时的bug状态是打开；接着由测试人员将《测试记录跟踪表》提交给项目经理，由项目经理指定bug修改负责人，当bug修改负责人解决bug后，将bug的状态改为“跟踪”，然后提交给测试人员，由测试人员进行验证测试，当测试人员验证测试成功，则bug状态改为“关闭”，当测试人员验证测试失败后，则bug的状态改为“重新打开”，最为bug重新处理。36，编码过程中会统计哪些数据？这些数据存放在哪？答：在编码阶段，我们收集项目规模，数据都记录在《项目总结报告》中。37，项目经理是如何检查你们工作的？答：主要根据周会，里程碑会议来检查工作，同时在平时我们发现问题也会EMAIL或走查的形式通知项目经理，项目经理也会根据《项目进度表》监控我们的工作进展情况。38，你的项目是否有内部制定保证？答：有PPQA是根据QA制定的《检查表》在每个检查时机处检查我的工作，并将发现的NC通过EMAIL的形式发给我，我在接到NC一天内给予反馈。 以上是作为开发人员问的问题，测试人员没怎么问，就问了一道题，还是和开发人员重合的为35题。下午，第2，3个项目一起进入会议室访谈。 第三天上午他们在会议室对访谈内容进行分析，下午快下班时召开初步发现会议让我们对他们给出的访谈分析结果提出异议。 第四天上午，最终发布会议，全员都要参加。]]></content>
      <categories>
        <category>经历</category>
      </categories>
      <tags>
        <tag>CMMI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS图片压缩]]></title>
    <url>%2F2016%2F09%2F03%2FiOS%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在做iOS开发中，经常会遇到这样的问题，图片尺寸太大，或者文件体积太大，需要将图片压缩处理一下，然后上传服务器。&emsp;&emsp;当然，也不排除一些公司要求app上传原图，但是这种方式太耗流量且很耗时间，如果网络不佳，很容易上传失败，从而会失去一些用户。 1, 理解概念:1, “压” 是指文件体积变小，但是像素数不变，长宽尺寸不变，那么质量可能下降。2, “缩” 是指文件的尺寸变小，也就是像素数减少，而长宽尺寸变小，文件体积同样会减小。 2, 图片“压”处理:对于“压”功能，我们可以使用UIImageJPEGRepresentation或UIImagePNGRepresentation方法实现，如：1NSData *imgData = UIImageJPEGRepresentation(image, 0.5); 第一个参数是图片对象本身，第二个参数是压的系数，其值范围为(0-1);UIImageJPEGRepresentation的官方注释:The quality of the resulting JPEG image, expressed as a value from 0.0 to 1.0. The value 0.0 represents the maximum compression (or lowest quality) while the value 1.0 represents the least compression (or best quality).关于PNG和JPEG格式压缩:1. UIImageJPEGRepresentation函数需要两个参数:图片的引用和压缩系数而UIImagePNGRepresentation只需要图片引用作为参数.2.UIImagePNGRepresentation(UIImage *image)要比UIImageJPEGRepresentation(UIImage* image, 1.0)返回的图片数据量大很多项目中做图片上传之前，经过测试同一张拍照所得照片png大小在8M，而JPG压缩系数为0.75时候，大小只有1M。而且，将压缩系数降低对图片视觉上并没有太大的影响。友情提示：压缩系数不宜太低，通常是0.3~0.7，过小则可能会出现黑边等 3, 图片“缩”处理:主要通过 [image drawInRect:CGRectMake(0, 0, targetWidth, targetHeight)]; 实现。 12345678910111213141516171819202122232425262728293031323334353637/** * 1, 按图片最大边成比例缩放图片 * * @param image 图片 * @param maxSize 图片的较长那一边目标缩到的(宽度／高度) * * @return 等比缩放后的图片 */ - (UIImage *)scaleImage:(UIImage *)image maxSize:(CGFloat)maxSize &#123; NSData *data = UIImageJPEGRepresentation(image, 1.0); if(data.length &lt; 200 * 1024)&#123;//0.25M-0.5M(当图片小于此范围不压缩) return image; &#125; CGFloat imageWidth = image.size.width; CGFloat imageHeight = image.size.height; CGFloat targetWidth = imageWidth; CGFloat targetHeight = imageHeight; CGFloat imageMaxSize = MAX(imageWidth, imageHeight); if (imageMaxSize &gt; maxSize) &#123; CGFloat scale = 0; if (imageWidth &gt;= imageHeight) &#123;// 宽长 scale = maxSize / imageWidth; targetWidth = maxSize; targetHeight = imageHeight * scale; &#125; else &#123; // 高长 scale = maxSize / imageHeight; targetHeight = maxSize; targetWidth = imageWidth * scale; &#125; UIGraphicsBeginImageContext(CGSizeMake(targetWidth, targetHeight)); [image drawInRect:CGRectMake(0, 0, targetWidth, targetHeight)]; UIImage *scaledImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return scaledImage; &#125; return image;&#125; 12345678910111213141516/** * 2, 图片支持等比缩放 * * @param image 图片 * @param maxSize 缩放比例(通常0～1之间) * * @return 等比缩放后的图片 */- (UIImage *)scaleImage:(UIImage *)image toScale:(float)scaleSize &#123; UIGraphicsBeginImageContext(CGSizeMake(image.size.width *scaleSize, image.size.height * scaleSize)); [image drawInRect:CGRectMake(0, 0, image.size.width * scaleSize, image.size.height * scaleSize)]; UIImage *scaledImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return scaledImage;&#125; 123456789101112131415/** * 3, 等比缩放成自定长宽的图片 * * @param image 源图片 * @param targetSize 自定义目标图片的size * * @return 处理后图片 */- (UIImage *)scaleImage:(UIImage *)image toSize:(CGSize)targetSize &#123; UIGraphicsBeginImageContext(CGSizeMake(targetSize.width, targetSize.height)); [image drawInRect:CGRectMake(0, 0, targetSize.width, targetSize.height)]; UIImage *targetSizeImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return targetSizeImage;&#125; 我们对图片只“压”而不缩，有时候是达不到我们的需求的。因此，适当地对图片“缩“一下尺寸，就可以满足我们的需求。1234567891011121314//根据图片附获取图片大小(多少M)方法- (NSData *)imageData:(UIImage *)image &#123; NSData *data = UIImageJPEGRepresentation(image, 1.0); if (data.length &gt; 100*1024) &#123; if (data.length &gt; 1024*1024) &#123;//1M以及以上 data = UIImageJPEGRepresentation(image, 0.1); &#125; else if (data.length &gt; 512*1024) &#123;//0.5M-1M data = UIImageJPEGRepresentation(image, 0.5); &#125; else if (data.length &gt; 200*1024) &#123;//0.25M-0.5M data = UIImageJPEGRepresentation(image, 0.9); &#125; &#125; return data;&#125; 验证：以模拟器第二张绿叶图片为例原图大小为24.9M, 4288 * 2848像素；经一次UIImageJPEGRepresentation“压“处理12UIImage *tmpImage = [UIImage imageWithContentsOfFile:photo.photoPath];NSData *imageData = UIImageJPEGRepresentation(tmpImage, 0.5); 图片大小为836.9K, 4288 * 2848像素； 经一次UIImagePNGRepresentation“压“处理12UIImage *tmpImage = [UIImage imageWithContentsOfFile:photo.photoPath]; NSData *imageData = UIImagePNGRepresentation(tmpImage); 图片大小为24.9M, 4288 * 2848像素；几乎没变 经一次“缩“处理(笔者给予图片最大的宽度限定为640像素)12UIImage *tmpImage = [UIImage imageWithContentsOfFile:photo.photoPath];tmpImage = [self scaleImage:tmpImage maxSize:640]; 图片大小为795.9K, 640 * 426像素； 经一次“压缩”处理:123UIImage *tmpImage = [UIImage imageWithContentsOfFile:photo.photoPath];tmpImage = [self scaleImage:tmpImage maxSize:640]; NSData *imageData = UIImageJPEGRepresentation(tmpImage, 0.5); 图片大小为698K, 640 * 426像素；大家可以根据实际调整不同参数以达到自己的项目要求。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
