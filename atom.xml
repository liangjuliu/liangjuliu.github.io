<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>良局｜博客</title>
  
  <subtitle>我走的很慢，但我永不后退。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuliangju.github.io/"/>
  <updated>2019-03-30T11:51:09.442Z</updated>
  <id>https://liuliangju.github.io/</id>
  
  <author>
    <name>LiangJu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>06:从尾到头打印链表</title>
    <link href="https://liuliangju.github.io/2019/03/30/%E5%89%91%E6%8C%87offer/201903/06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://liuliangju.github.io/2019/03/30/剑指offer/201903/06从尾到头打印链表/</id>
    <published>2019-03-30T08:54:22.000Z</published>
    <updated>2019-03-30T11:51:09.442Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 自定义节点，包含数据域和指针域</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *String value;</span></span><br><span class="line"><span class="comment"> *  ListNode next;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public ListNode(String value, ListNode next) &#123;</span></span><br><span class="line"><span class="comment"> *      this.value = value;</span></span><br><span class="line"><span class="comment"> *      this.next = next;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *    public ListNode(String value) &#123;</span></span><br><span class="line"><span class="comment"> *this.value = value;</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseNode</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ListNode head = <span class="keyword">new</span> ListNode(<span class="string">"a"</span>);</span><br><span class="line">ListNode node1 = <span class="keyword">new</span> ListNode(<span class="string">"b"</span>);</span><br><span class="line">ListNode node2 = <span class="keyword">new</span> ListNode(<span class="string">"c"</span>);</span><br><span class="line">ListNode node3 = <span class="keyword">new</span> ListNode(<span class="string">"d"</span>);</span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line">head.next = node1;</span><br><span class="line">node1.next = node2;</span><br><span class="line">node2.next = node3;</span><br><span class="line">PrintReversingly_Iteratively(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintReversingly_Iteratively</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">Stack&lt;ListNode&gt; nodeStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">nodeStack.push(node);</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!nodeStack.isEmpty()) &#123;</span><br><span class="line">ListNode tempNode = nodeStack.pop();</span><br><span class="line">System.out.println(tempNode.value);<span class="comment">// 打印元素</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表定义如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="剑指Offer学习" scheme="https://liuliangju.github.io/categories/%E5%89%91%E6%8C%87Offer%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://liuliangju.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>题目5:替换空格</title>
    <link href="https://liuliangju.github.io/2019/03/30/%E5%89%91%E6%8C%87offer/201903/05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://liuliangju.github.io/2019/03/30/剑指offer/201903/05替换空格/</id>
    <published>2019-03-30T02:47:12.000Z</published>
    <updated>2019-03-30T11:51:09.442Z</updated>
    
    <content type="html"><![CDATA[<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h4><p>请实现一个函数，把字符串中的每个空格替换成”%20”。例如，输入 “We are happy.”，则输出 “We%20are%20happy.”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceBlank</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">str.append(string);</span><br><span class="line"><span class="keyword">if</span> (str.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> originalLength = str.length();</span><br><span class="line"><span class="keyword">int</span> numberOfBlank = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; originalLength; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">numberOfBlank++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> newLength = originalLength + <span class="number">2</span> * numberOfBlank;</span><br><span class="line">str.setLength(newLength);</span><br><span class="line"><span class="keyword">int</span> indexOfOriginal = originalLength - <span class="number">1</span>; <span class="comment">// 原来字符串的索引</span></span><br><span class="line"><span class="keyword">int</span> indexOfNew = newLength - <span class="number">1</span>; <span class="comment">// 新字符串的索引</span></span><br><span class="line"><span class="keyword">while</span> (indexOfOriginal &gt;= <span class="number">0</span> &amp;&amp; indexOfNew &gt; indexOfOriginal) &#123;</span><br><span class="line"><span class="keyword">if</span> (str.charAt(indexOfOriginal) == <span class="string">' '</span>) &#123;</span><br><span class="line">str.setCharAt(indexOfNew--, <span class="string">'0'</span>);</span><br><span class="line">str.setCharAt(indexOfNew--, <span class="string">'2'</span>);</span><br><span class="line">str.setCharAt(indexOfNew--, <span class="string">'%'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">str.setCharAt(indexOfNew--, str.charAt(indexOfOriginal));</span><br><span class="line">&#125;</span><br><span class="line">--indexOfOriginal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;替换空格&quot;&gt;&lt;a href=&quot;#替换空格&quot; class=&quot;headerlink&quot; title=&quot;替换空格&quot;&gt;&lt;/a&gt;替换空格&lt;/h4&gt;&lt;p&gt;请实现一个函数，把字符串中的每个空格替换成”%20”。例如，输入 “We are happy.”，则输出 “We%20are
      
    
    </summary>
    
      <category term="剑指Offer学习" scheme="https://liuliangju.github.io/categories/%E5%89%91%E6%8C%87Offer%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://liuliangju.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>题目3:数组中重复的数字</title>
    <link href="https://liuliangju.github.io/2019/03/28/%E5%89%91%E6%8C%87offer/201903/03.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://liuliangju.github.io/2019/03/28/剑指offer/201903/03.数组中重复的数字/</id>
    <published>2019-03-27T22:52:54.000Z</published>
    <updated>2019-03-30T11:51:09.440Z</updated>
    
    <content type="html"><![CDATA[<h4 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h4><p>在一个长度为n的数组里的所有数字都在n～n-1范围内，数组中的某个数字是重复的，但是不知道有几个数字重复了，也不知道每个数字重复了几次，请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3},那么对应的输出是重复的数字2或者数字3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = numbers.length;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt; len - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] dup = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (numbers[i] != i) &#123;</span><br><span class="line"><span class="keyword">if</span> (numbers[i] == numbers[numbers[i]]) &#123;</span><br><span class="line">dup[j++] = numbers[i];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp = numbers[i];</span><br><span class="line">numbers[i] = numbers[tmp];</span><br><span class="line">numbers[tmp] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;找出数组中重复的数字&quot;&gt;&lt;a href=&quot;#找出数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;找出数组中重复的数字&quot;&gt;&lt;/a&gt;找出数组中重复的数字&lt;/h4&gt;&lt;p&gt;在一个长度为n的数组里的所有数字都在n～n-1范围内，数组中的某个数字是重复
      
    
    </summary>
    
      <category term="剑指Offer学习" scheme="https://liuliangju.github.io/categories/%E5%89%91%E6%8C%87Offer%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://liuliangju.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>iOS - 分类中方法的调用顺序</title>
    <link href="https://liuliangju.github.io/2018/10/09/iOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/201810/iOS-%E5%88%86%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F/"/>
    <id>https://liuliangju.github.io/2018/10/09/iOS基础总结/201810/iOS-分类中方法的调用顺序/</id>
    <published>2018-10-09T14:04:51.000Z</published>
    <updated>2018-10-11T12:56:34.062Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;前几日看老司机专栏发布过一篇文章-<a href="https://xiaozhuanlan.com/topic/1278405369" target="_blank" rel="noopener">iOS 上修改私有方法的几种方式解析</a>，文章中提到了我们通常修改一个类私有方法的方式有以下四种：</p><ul><li>通过创建 Category 复写，这种方式简单而粗暴。</li><li>通过 <code>void method_exchangeImplementations(Method m1, Method m2)</code> 等类似方式实现 <code>Method Swizzling</code>，也就是所谓 的黑魔法。</li><li>通过第三方框架 <code>Aspects</code> 来修改私有方法，对于项目内有强 AOP 编程需求的很可能会选择这个方式。</li><li>通过Facebook开源的 Fishhook 对 C 语言方法进行了 Hook 的方式，它在逆向技术中占据了很大的作用。OC 的消息转发机制是依赖于 C 函数 objc_msgSend ，那么在一些特殊需求需要直接 Hook C 函数的话，Fishhook 就会派上用场了。</li></ul><p>从而想到了总结下iOS在多个<code>Category</code>重名时，方法的调用这么一篇文章。</p><p>本文主要侧重于解决以下几个问题：</p><ol><li>主类和分类中普通方法的调用顺序?</li><li>同一个主类的两个分类中的同名方法调用顺序?</li><li>分类中 +load 方法的调用顺序?</li><li>分类中 +initialize 方法的调用顺序?</li></ol><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>新建一个workspace工程，我创建了一个TestDemo工程然后创建对主类<code>MyClass</code>创建了几个分类了<img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201810/20181011001.png"> </p><h5 id="主类、子类和分类中的-void-load方法的调用顺序"><a href="#主类、子类和分类中的-void-load方法的调用顺序" class="headerlink" title="主类、子类和分类中的+ (void)load方法的调用顺序"></a>主类、子类和分类中的<strong><code>+ (void)load</code></strong>方法的调用顺序</h5><p>在主类和子类、分类中重写+load方法</p><ol><li>情形一<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201810/20181011002.png"> </li><li>情形二<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201810/20181011003.png"> </li><li>情形三<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201810/20181011004.png"> </li><li>情形四<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201810/20181011005.png"> <h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><table class="table table-bordered table-condensed"><tr><td bgcolor="Gainsboro">1.&nbsp;主类和子类、分类的都会主动调用 +load 方法<br>2.&nbsp;主类和子类加载顺序与编译顺序无关，调用优先级为<font color="purple">父类优先于子类</font>。<br>3.&nbsp;分类间的加载顺序取决于编译的顺序:编译在前则先加载, 编译在后则后加载。<br>4.&nbsp;父类、子类、分类的加载顺序为：父类优先于子类，子类优先于分类<font color="purple">(父类&gt;子类&gt;分类)</font>。</td></tr></table></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前几日看老司机专栏发布过一篇文章-&lt;a href=&quot;https://xiaozhuanlan.com/topic/1278405369&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS 上修改私有方法的几
      
    
    </summary>
    
      <category term="iOS" scheme="https://liuliangju.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://liuliangju.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中几种锁的总结</title>
    <link href="https://liuliangju.github.io/2018/05/10/iOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/201805/iOS%E4%B8%AD%E5%87%A0%E7%A7%8D%E9%94%81%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://liuliangju.github.io/2018/05/10/iOS基础总结/201805/iOS中几种锁的总结/</id>
    <published>2018-05-10T09:08:17.000Z</published>
    <updated>2018-08-14T13:47:34.847Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;iOS开发中，为了提升程序的运行效率，增强用户体验，我们经常使用多线程，在使用多线程中，我们应该<strong>尽量避免资源在线程中共享，减少线程中的相互作用</strong>，我们采用锁的机制来确保线程安全。</p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当一个线程访问数据的时候，其他的线程不能对其进行数据访问，更不能对其进行数据修改，直到该线程访问完毕。即，同一时刻，对同一个数据的操作的线程只有一个。只有这样，才能使数据不被其他线程污染；而线程不安全，则是同一时刻可以有多个线程对该数据进行访问，从而得不到预期的结果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;比如读写数据库，当一个线程在写数据的时候，如果这个时候另一个线程来直接读取数据，那么有可能得到的将是不可预期的结果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;通常我们使用锁的机制来保证线程安全，即确保同一时刻只有同一个线程来对同一个数据源进行访问。在开发中我们经常使用以下几种锁:</p><ol><li>NSLock</li><li>@synchronized</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>pthread_mutex</li><li>pthread_rwlock</li><li>dispatch_semaphore</li><li>OSSpinLock</li></ol><h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><p>NSLock实现了最基本的互斥锁，遵循了NSLocking协议，通过 lock 和 unlock 来进行锁定和解锁，其使用也非常简单</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc]init];</span><br><span class="line">  [lock lock];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"加锁成功"</span>);</span><br><span class="line">  sleep(<span class="number">2</span>);</span><br><span class="line">  [lock unlock];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"解锁成功"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：lock与unlock操作必须在同一线程，否则结果不确定甚至会引起死锁</p></blockquote><p>由于是互斥锁，当一个线程进行访问的时候，该线程获得锁，其他线程进行访问的时候，将被操作系统挂起，直到该线程释放锁，其他线程才能对其进行访问，从而却确保了线程安全。但是如果连续锁定两次，则会造成死锁问题。</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h4><p>@synchronized是 iOS 中最常见的锁，用法很简单：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)synchronizeDemo &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    <span class="keyword">@synchronized</span>(object) &#123; <span class="comment">//这里添加一个OC对象，一般使用self</span></span><br><span class="line">        <span class="comment">// Everything between the braces is protected by the @synchronized directive.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：1.加锁的代码尽量少<br>　　  2.添加的OC对象必须在多个线程中都是同一对象，下面举一个反例</p></blockquote><p>我们看一个经典的卖票例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 设置车票总张数10 张</span></span><br><span class="line">    _tickets = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程一</span></span><br><span class="line">    <span class="built_in">NSThread</span> *threadOne = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTickets) object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程二</span></span><br><span class="line">    <span class="built_in">NSThread</span> *threadTwo = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTickets) object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启线程</span></span><br><span class="line">    [threadOne start];</span><br><span class="line">    [threadTwo start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)saleTickets &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">@synchronized</span>(object) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (_tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                _tickets --;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"剩余票数= %ld"</span>,_tickets);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"票卖没了"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果卖票出错了，出现这个原因的问题是每个线程都会创建一个object对象，锁后面加的object在不同线程中了从而导致卖票出差。<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201805/20180511001.png"><br>把@synchronized（object）改成 @synchronized（self）就能得到了正确结果<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201805/20180511002.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;iOS开发中，为了提升程序的运行效率，增强用户体验，我们经常使用多线程，在使用多线程中，我们应该&lt;strong&gt;尽量避免资源在线程中共享，减少线程中的相互作用&lt;/strong&gt;，我们采用锁的机制来确保线程安全。&lt;/p&gt;
&lt;h4
      
    
    </summary>
    
      <category term="iOS" scheme="https://liuliangju.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://liuliangju.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>经典算法之插入排序(Insertion Sort)</title>
    <link href="https://liuliangju.github.io/2018/04/27/%E5%89%91%E6%8C%87offer/201804/01.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://liuliangju.github.io/2018/04/27/剑指offer/201804/01.插入排序/</id>
    <published>2018-04-26T22:08:07.000Z</published>
    <updated>2019-03-30T11:51:09.438Z</updated>
    
    <content type="html"><![CDATA[<p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"><br></script></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>设有一组关键字 {K<sub>1</sub>, K<sub>2</sub>, …, K<sub>n</sub>}; 排序开始就认为K<sub>1</sub>是一个有序的序列，使之成为一个表厂为2的有序序列；然后让K<sub>3</sub>插入上述表长为2的有序序列，使之成为一个表长为3的有序序列，以此类推，最后让K<sub>n</sub>插入上述表长为n-1的有序序列，得一个表长为n的有序序列。</p><p>具体可以表述为下：</p><ol><li>从第一个元素开始，该元素可以认为已经排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素(已排序)大于新元素，将该元素移到下一个位置</li><li>重复步骤3，直到找到已排序的元素小于或等于新元素的位置</li><li>将新元素插入该位置后</li><li>重复步骤2～5</li></ol><p>举例说明：要排序数组：int[] arr = {6, 3, 8, 2, 9, 1}; </p><p>第一趟排序：原始数据：<font color="red"> 6 </font> 3 8 2 9 1 <code>i=0</code><br>从第一个元素开始，该元素可以认为已经排序<br>排序结果： 6 3 8 2 9 1</p><hr><p>第二趟排序： 6 <font color="red"> 3 </font> 8 2 9 1 <code>i=1</code><br>排序结果：3 6 8 2 9 1</p><hr><p>第三趟排序：3 6 <font color="red"> 8 </font>  2 9 1 <code>i=2</code><br>排序结果：3 6 8 2 9 1</p><hr><p>第四趟排序：3 6 8<font color="red"> 2 </font> 9 1 <code>i=3</code><br>排序结果：2 3 6 8 9 1</p><hr><p>第五趟排序：2 3 6 8<font color="red"> 9 </font> 1 <code>i=4</code><br>排序结果：2 3 6 8 9 1</p><hr><p>第六趟排序：2 3 6 8 9 <font color="red"> 1 </font>  <code>i=5</code><br>排序结果：1 2 3 6 8 9 </p><hr><p>最终结果：1  2  3  6  8  9</p><hr><blockquote><p>注：(红色代表此轮要插入的元素，红色左边是已经排好序的，右边是待排序的)</p></blockquote><hr><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>在最坏情况下，数组完全逆序，插入第2个元素时要考察前1个元素，插入第3个元素时，要考虑前2个元素，……，插入第n个元素，要考虑前 n - 1 个元素。因此，最坏情况下的比较次数是 1 + 2 + 3 + … + (n - 1)，等差数列求和，结果为 n<sup>2</sup> / 2，所以最坏情况下的复杂度为 O(n<sup>2</sup>)</p><p>最好情况下，数组已经是有序的，每插入一个元素，只需要考查前一个元素，因此最好情况下，插入排序的时间复杂度为O(n)</p><p>平均时间复杂度为：O(n<sup>2</sup>)</p><p>所以，综上，插入排序的时间复杂度为 O(n<sup>2</sup>)。</p><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j, tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"> tmp = nums[i];</span><br><span class="line"> j = i - <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; nums[j]) &#123;</span><br><span class="line">     nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">     j--;</span><br><span class="line">&#125;</span><br><span class="line">nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;br&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h4 
      
    
    </summary>
    
      <category term="剑指Offer学习" scheme="https://liuliangju.github.io/categories/%E5%89%91%E6%8C%87Offer%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://liuliangju.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>经典算法之选择排序(Selection Sort)</title>
    <link href="https://liuliangju.github.io/2018/04/24/%E5%89%91%E6%8C%87offer/201804/03.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://liuliangju.github.io/2018/04/24/剑指offer/201804/03.选择排序/</id>
    <published>2018-04-23T23:19:54.000Z</published>
    <updated>2019-03-30T11:51:09.439Z</updated>
    
    <content type="html"><![CDATA[<p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"><br></script></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>选择排序是一种简单直观的排序算法，其基本原理如下：对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录的位置与第一个记录的位置交换；接着对不包括第一个记录以外的其他记录进行第二次比较，得到最小记录并与第二个位置记录交换；重复该过程，直到进行比较的记录只剩下一个为止。<br>举例说明：要排序数组：int[] arr = {6, 3, 8, 2, 9, 1}; </p><p>第一趟排序：原始数据：6 3 8 2 9 1<br>最小数据为1，把1放在首位，也就是1和6交换位置，<br>排序结果：1 3 8 2 9 6</p><hr><p>第二趟排序：除第一个元素以外的其他数据进行比较{3 8 2 9 6}, 2最小，2和3交换位置，<br>排序结果：1 2 8 3 9 6</p><hr><p>第三趟排序：除1、2以外的其他数据进行比较{8 3 9 6}, 3最小，3和8交换位置，<br>排序结果：1 2 3 8 9 6</p><hr><p>第四趟排序：除1、2、3以外的其他数据进行比较{8 9 6}, 6最小，6和8交换位置，<br>排序结果：1 2 3 6 9 8</p><hr><p>第五趟排序：除1、2、3、6以外的其他数据进行比较{8 9}, 8最小，8和9交换位置，<br>排序结果：1 2 3 6 8 9</p><hr><p>最终结果：1  2  3  6  8  9</p><hr><p>注：每一趟排序获取最小数的方法：for循环进行比较，将当前下标定义为最小值下标值用临时变量<code>temp</code>保存，然后用<code>temp</code>再去跟剩下的数据比较，如果出现比<code>temp</code>小的数据，就用它代替<code>temp</code>中原有的数据。</p><hr><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 n 个元素，则比较次数永远都是n (n - 1) / 2。而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为3n (n - 1) /  2。</p><p>所以，综上，简单排序的时间复杂度为 O(n<sup>2</sup>)。</p><p>尽管与冒泡排序同为O(n<sup>2</sup>)，但简单选择排序的性能要优于冒泡排序。</p><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = nums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> k = i;  <span class="comment">//临时变量k，假使k为最小元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123; <span class="comment">// 选最小的记录</span></span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[k]) &#123;</span><br><span class="line">     k = j;  <span class="comment">//记下目前找到的最小值所在的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i != k) &#123;</span><br><span class="line">     swapNums(nums, i, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">    System.out.println(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] swapNums(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line"><span class="comment">//int tmp = nums[i];</span></span><br><span class="line"><span class="comment">//nums[i] = nums[j];</span></span><br><span class="line"><span class="comment">//nums[j] = tmp;</span></span><br><span class="line"></span><br><span class="line">nums[i] = nums[i]^nums[j];</span><br><span class="line">nums[j] = nums[i]^nums[j];</span><br><span class="line">nums[i] = nums[i]^nums[j];</span><br><span class="line"><span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;br&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h4 
      
    
    </summary>
    
      <category term="剑指Offer学习" scheme="https://liuliangju.github.io/categories/%E5%89%91%E6%8C%87Offer%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://liuliangju.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>经典算法之冒泡排序(Bubble Sort)</title>
    <link href="https://liuliangju.github.io/2018/04/24/%E5%89%91%E6%8C%87offer/201804/02.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://liuliangju.github.io/2018/04/24/剑指offer/201804/02.冒泡排序/</id>
    <published>2018-04-23T22:05:13.000Z</published>
    <updated>2019-03-30T11:51:09.438Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>比较两个相邻的元素，将值大的元素交换至右端。<br>思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。（这里只介绍常用的简单选择排序）</p><p>举例说明：要排序数组：int[] arr = {6, 3, 8, 2, 9, 1};   </p><p>第一趟排序：</p><p>　　　　第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1</p><p>　　　　第二次排序：6和8比较，6小于8，不交换位置：3  6  8  2  9  1</p><p>　　　　第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1</p><p>　　　　第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1</p><p>　　　　第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9</p><p>　　　　第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9</p><hr><p>第二趟排序：</p><p>　　　　第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9</p><p>　　　　第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9</p><p>　　　　第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9</p><p>　　　　第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9</p><p>　　　　第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9</p><hr><p>第三趟排序：</p><p>　　　　第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9</p><p>　　　　第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9</p><p>　　　　第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9</p><p>　　　　第二趟总共进行了3次比较， 排序结果：         2  3  1  6  8  9</p><hr><p>第四趟排序：</p><p>　　　　第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9</p><p>　　　　第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9</p><p>　　　　第二趟总共进行了2次比较， 排序结果：        2  1  3  6  8  9</p><hr><p>第五趟排序：</p><p>　　　　第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9</p><p>　　　　第二趟总共进行了1次比较， 排序结果：  1  2  3  6  8  9</p><hr><p>最终结果：1  2  3  6  8  9</p><hr><p>由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;arr.length-i;j++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>　1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。</p><p>　2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：冒泡排序的最坏时间复杂度为：O(n<sup>2</sup>) 。</p><p>综上所述：冒泡排序总的平均时间复杂度为：O(n<sup>2</sup>) 。</p><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = nums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123; <span class="comment">//外层循环控制排序趟数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length -<span class="number">1</span> - i; j++) &#123; <span class="comment">//内层循环控制每一趟排序多少次</span></span><br><span class="line"><span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">swapNums(nums, j, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">System.out.println(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] swapNums(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line"><span class="comment">//int tmp = nums[i];</span></span><br><span class="line"><span class="comment">//nums[i] = nums[j];</span></span><br><span class="line"><span class="comment">//nums[j] = tmp;</span></span><br><span class="line"></span><br><span class="line">nums[i] = nums[i]^nums[j];</span><br><span class="line">nums[j] = nums[i]^nums[j];</span><br><span class="line">nums[i] = nums[i]^nums[j];</span><br><span class="line"><span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h4&gt;&lt;p&gt;比较两个相邻的元素，将值大的元素交换至右端。&lt;br&gt;思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第
      
    
    </summary>
    
      <category term="剑指Offer学习" scheme="https://liuliangju.github.io/categories/%E5%89%91%E6%8C%87Offer%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://liuliangju.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>内存泄漏检测</title>
    <link href="https://liuliangju.github.io/2018/04/20/iOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/201804/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/"/>
    <id>https://liuliangju.github.io/2018/04/20/iOS基础总结/201804/内存泄漏检测/</id>
    <published>2018-04-19T21:44:35.000Z</published>
    <updated>2018-04-19T22:43:11.490Z</updated>
    
    <content type="html"><![CDATA[<p>首先要明确下基本定义，什么叫内存泄漏？</p><ul><li>内存泄漏(memory leak) ：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</li><li>内存溢出(out of memory) ：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。通俗理解就是内存不够，通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。</li></ul><h4 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h4><h5 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h5><p>通过<code>Xcode</code>打开项目，然后点击product -&gt; Analyze 分析，<br>    <img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201804/2018042001.png"><br>    <img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201804/2018042002.png"><br>静态分析方法能发现大部分的问题，但是只能是静态分析结果，有一些并不准确，还有一些动态分配内存的情形并没有进行分析。所以仅仅使用静态内存泄漏分析得到的结果并不是非常可靠，如果需要，我们需要将对项目进行更为完善的内存泄漏分析和排查。那就需要用到我们下面要介绍的动态内存泄漏分析方法Instruments中的Leaks方法进行排查。</p><h5 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h5><p>静态分析不能把所有的内存泄露排查出来，有的内存泄露是在运行时，用户操作时才产生的。那就需要用到Instruments了。具体操作是通过xcode打开项目，然后点击product–&gt;profile。</p><h5 id="dealloc分析"><a href="#dealloc分析" class="headerlink" title="dealloc分析"></a>dealloc分析</h5><p>通过在<code>dealloc</code>打印，来确定当前类是否被释放</p><h5 id="借助于第三方库检测"><a href="#借助于第三方库检测" class="headerlink" title="借助于第三方库检测"></a>借助于第三方库检测</h5><p>借助于第三方库检测，如 <a href="https://github.com/facebook/FBRetainCycleDetector" target="_blank" rel="noopener">FBRetainCycleDetector</a> 、 <a href="https://github.com/Tencent/OOMDetector" target="_blank" rel="noopener">OOMDetector</a> 等</p><h4 id="常见内存泄漏原因"><a href="#常见内存泄漏原因" class="headerlink" title="常见内存泄漏原因"></a>常见内存泄漏原因</h4><ol><li>ViewController 中存在NSTimer</li><li>ViewController 中的代理delegate</li><li>ViewController 中Block</li><li>ViewController 的子视图对self的持有</li><li>ViewController 之间的循环引用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先要明确下基本定义，什么叫内存泄漏？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存泄漏(memory leak) ：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。&lt;/li&gt;
&lt;li&gt;内存溢出(out of
      
    
    </summary>
    
      <category term="iOS基础" scheme="https://liuliangju.github.io/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="iOS" scheme="https://liuliangju.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>define宏定义和const定义常量区别</title>
    <link href="https://liuliangju.github.io/2018/04/10/iOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/201804/iOS%20define%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Cconst%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%88%AB/"/>
    <id>https://liuliangju.github.io/2018/04/10/iOS基础总结/201804/iOS define宏定义和const定义常量区别/</id>
    <published>2018-04-10T09:08:17.000Z</published>
    <updated>2018-10-09T13:48:49.836Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;由于需求不断的添加，工程越来越大，编译速度是越来越慢。之前就看过帖子:</p><blockquote><p>使用宏定义过多的话，随着工程越来越大，编译速度会越来越慢。  </p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;当时也想过替换成常量，但是当时的替换方法有问题，导致编译的时候有很多重复的变量，替换失败了，就不了了之，直到最近，每次编译的时间实在是超出了我的容忍极限，于是下定决心，一定要替换掉。又从网上查看帖子，从简书上看到了这篇文章<a href="https://www.jianshu.com/p/2fd58ed2cf55" target="_blank" rel="noopener">【如何正确使用const,static,extern】|那些人追的干货</a>。</p><p>以下为一段替换后的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> kHeaderImageWidth = <span class="number">100</span>; <span class="comment">//Header宽度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> kHeaderImageHeight = <span class="number">100</span>; <span class="comment">//Header宽度</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> kHeaderImageY = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> kPadding = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><blockquote><p>const 是c++中的修饰符。  c++中常用来定义常量，修饰左值。</p></blockquote><p>补充说明：以上的类型常量替换宏的情况，只是适用于单个文件的情况。如果是多个文件共享的常量，苹果推荐的这样的方式:</p><ul><li>LJConstant.h</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> LJFirstHeaderHeight; <span class="comment">// 分组页面第一个分组的header高度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> LJOtherHeaderHeight; <span class="comment">// 分组页面其它分组的header高度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> LJLastFooterHeight; <span class="comment">// 分组页面最后一个分组的footer高度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> LJOtherFooterHeight; <span class="comment">// 分组页面最后其它分组的footer高度</span></span><br></pre></td></tr></table></figure><ul><li>LJConstant.m</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> <span class="keyword">const</span> LJFirstHeaderHeight = <span class="number">15.0</span>f; <span class="comment">// 分组页面第一个分组的header高度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> <span class="keyword">const</span> LJOtherHeaderHeight = <span class="number">20.0</span>f; <span class="comment">// 分区页面其它分组的header高度//20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> <span class="keyword">const</span> LJLastFooterHeight = <span class="number">15.0</span>f; <span class="comment">// 分组页面最后一个分组的footer高度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> <span class="keyword">const</span> LJOtherFooterHeight = <span class="number">0.1</span>f; <span class="comment">// 分组页面最后其它分组的footer高度</span></span><br></pre></td></tr></table></figure><blockquote><p> #define 宏定义语句, 在预处理阶段直接做文本替换，不做类型检查。</p></blockquote><p>它们之间的最大区别:</p><p>1.对于<code>const</code>变量，系统只给了一个相应的内存地址，而<code>#define</code>则是给出了一个立即数。因为<code>const</code>变量是存放在内存的静态区域中，所以在程序运行过程中<code>const</code>变量只有一个拷贝，而<code>#define</code>所定义的宏变量却有多个拷贝，所以宏在程序运行过程中所消耗的内存要比<code>const</code>变量的大得多。<code>#define</code>所定义的宏变量在预编译的时候进行替换，<code>const</code>变量在编译时确定其值。<code>const</code>,<code>enum</code>变量进符号表，可在调试中查看变量的值.而<code>#define</code>不行。</p><p>2.<code>const</code>对数据进行类型检查。<code>#define</code>无需进行类型检查。定义宏参数时需将参数（）起来。而且调用时参数不应在宏中再做运算。</p><p>3.除了定义常量外，<code>const</code>还有强大的修饰功能。<code>#define</code>能增加程序的可读性，有些复杂的功能只需一条宏显示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于需求不断的添加，工程越来越大，编译速度是越来越慢。之前就看过帖子:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用宏定义过多的话，随着工程越来越大，编译速度会越来越慢。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbs
      
    
    </summary>
    
      <category term="iOS" scheme="https://liuliangju.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://liuliangju.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>第二篇：初识汇编</title>
    <link href="https://liuliangju.github.io/2018/03/23/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/201803/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/"/>
    <id>https://liuliangju.github.io/2018/03/23/安全攻防/201803/初识汇编/</id>
    <published>2018-03-23T12:40:47.000Z</published>
    <updated>2018-04-26T14:26:10.006Z</updated>
    
    <content type="html"><![CDATA[<p>我们在学习逆向开发之前,我们要了解一个基本的逆向原理.首先我们是逆向iOS系统上面的APP.那么我们知道,一个APP安装在手机上面的可执行文件本质上是二进制文件.因为iPhone手机本质上执行的指令是二进制.是由手机上的CPU执行的.所以逆向开发是建立在分析二进制上面.</p><h2 id="汇编语言的发展"><a href="#汇编语言的发展" class="headerlink" title="汇编语言的发展"></a>汇编语言的发展</h2><h3 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h3><blockquote><p>由0和1组成的机器指令.</p></blockquote><ul><li>加：0100 0000</li><li>减：0100 1000</li><li>乘：1111 0111 1110 0000 </li><li>除：1111 0111 1111 0000 </li></ul><h3 id="汇编语言-assembly-language"><a href="#汇编语言-assembly-language" class="headerlink" title="汇编语言(assembly language)"></a>汇编语言(assembly language)</h3><blockquote><p>使用助记符代替机器语言<br>如:</p></blockquote><ul><li>加：INC EAX        通过编译器 0100 0000</li><li>减：DEC EAX        通过编译器 0100 1000</li><li>乘：MUL EAX         通过编译器 1111 0111 1110 0000</li><li>除：DIV EAX        通过编译器 1111 0111 1111 0000</li></ul><p>###高级语言（High-level programming language)</p><blockquote><p>C\C++\Java\OC\Swift,更加接近人类的自然语言<br>比如C语言:</p></blockquote><ul><li>加：A+B        通过编译器            0100 0000</li><li>减：A-B        通过编译器            0100 1000</li><li>乘：A*B     通过编译器            1111 0111 1110 0000</li><li>除：A/B        通过编译器            1111 0111 1111 0000</li></ul><p>我们的代码在终端设备上是这样的过程:<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/20180323001.jpg"></p><ul><li><strong>汇编语言</strong>与<strong>机器语言</strong>一一对应，每一条机器指令都有与之对应的汇编指令</li><li><strong>汇编语言</strong>可以通过编译得到<strong>机器语言</strong>，<strong>机器语言</strong>可以通过反汇编得到<strong>汇编语言</strong></li><li><strong>高级语言</strong>可以通过编译得到<strong>汇编语言</strong> \ <strong>机器语言</strong>，但汇编语言\机器语言几乎不可能还原成<strong>高级语言</strong></li></ul><h3 id="汇编语言的特点"><a href="#汇编语言的特点" class="headerlink" title="汇编语言的特点"></a>汇编语言的特点</h3><ul><li><p>可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能</p></li><li><p>能够不受编译器的限制，对生成的二进制代码进行完全的控制</p></li><li><p>目标代码简短，占用内存少，执行速度快</p></li><li><p>汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性</p></li><li><p>知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护</p></li><li><p>不区分大小写，比如mov和MOV是一样的</p></li></ul><h3 id="汇编的用途"><a href="#汇编的用途" class="headerlink" title="汇编的用途"></a>汇编的用途</h3><ul><li>编写驱动程序、操作系统（比如Linux内核的某些关键部分）</li><li>对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编）</li><li>软件安全<ul><li>病毒分析与防治</li><li>逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客</li></ul></li><li>理解整个计算机系统的最佳起点和最有效途径</li><li>为编写高效代码打下基础</li><li>弄清代码的本质<ul><li>函数的本质究竟是什么?</li><li>++a + ++a + ++a 底层如何执行的?</li><li>编译器到底帮我们干了什么?</li><li>DEBUG模式和RELEASE模式有什么关键的地方被我们忽略</li><li>……</li></ul></li></ul><h3 id="汇编语言的种类"><a href="#汇编语言的种类" class="headerlink" title="汇编语言的种类"></a>汇编语言的种类</h3><ul><li><p>目前讨论比较多的汇编语言有</p><ul><li>8086汇编（8086处理器是16bit的CPU）</li><li>Win32汇编</li><li>Win64汇编</li><li>ARM汇编（嵌入式、Mac、iOS）</li><li>……</li></ul></li><li><p>我们iPhone里面用到的是ARM汇编,但是不同的设备也有差异.因CPU的架构不同.</p></li></ul><table><thead><tr><th>架构</th><th>设备 </th></tr></thead><tbody><tr><td>armv6</td><td>iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch</td></tr><tr><td>armv7</td><td>iPhone3GS, iPhone4, iPhone4S,iPad, iPad2, iPad3(The New iPad), iPad mini, iPod Touch 3G, iPod Touch4</td></tr><tr><td>armv7s</td><td>iPhone5, iPhone5C, iPad4(iPad with Retina Display)</td></tr><tr><td>arm64</td><td>iPhone5S 以后 iPhoneX , iPad Air, iPad mini2以后</td></tr></tbody></table><h3 id="几个必要的常识"><a href="#几个必要的常识" class="headerlink" title="几个必要的常识"></a>几个必要的常识</h3><ul><li>要想学好汇编,首先需要了解CPU等硬件结构</li><li>APP/程序的执行过程</li></ul><p><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/20180323002.jpg"></p><ul><li>硬件相关最为重要是CPU/内存</li><li>在汇编中,大部分指令都是和CPU与内存相关的</li></ul><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/20180323003.jpg"><br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/20180323004.jpg"></p><ul><li>每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互</li><li>总线：一根根导线的集合</li><li>总线的分类<ul><li>地址总线</li><li>数据总线</li><li>控制总线</li></ul></li></ul><p><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/20180323005.jpg"></p><p><strong>举个例子</strong></p><p><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/20180323006.png" alt="来至书上的截图"></p><ul><li><strong>地址总线</strong><ul><li>它的宽度决定了CPU的<em>寻址能力</em></li><li>8086的地址总线宽度是_20_，所以寻址能力是_1M_（ 2^20  ）</li></ul></li></ul><p><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/20180323007.png"></p><ul><li><strong>数据总线</strong><ul><li>它的宽度决定了CPU的单次数据传送量，也就是数据<em>传送速度</em></li><li>8086的数据总线宽度是_16_，所以单次最大传递<em>2个字节</em>的数据</li></ul></li><li><strong>控制总线</strong><ul><li>它的宽度决定了CPU对其他器件的<em>控制能力</em>、能有多少种控制</li></ul></li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><img src="http://upload-images.jianshu.io/upload_images/2990730-cb3c46652c7bad8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各类存储区的逻辑连接"></p><p><img src="http://upload-images.jianshu.io/upload_images/2990730-49e73b88a2e7af92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各类存储器的逻辑连接-物理地址对应图"></p><p><img src="http://upload-images.jianshu.io/upload_images/2990730-d723c11cce5cdaaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各类存储器的物理地址情况"></p><ul><li><p>内存地址空间的大小受CPU地址总线宽度的限制。8086的地址总线宽度为20，可以定位2^20个不同的内存单元（内存地址范围0x00000~0xFFFFF），所以8086的内存空间大小为1MB</p></li><li><p>0x00000~0x9FFFF：主存储器。可读可写</p></li><li><p>0xA0000~0xBFFFF：向显存中写入数据，这些数据会被显卡输出到显示器。可读可写</p></li><li><p>0xC0000~0xFFFFF：存储各种硬件\系统信息。只读</p></li></ul><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p><strong>学习进制的障碍</strong></p><blockquote><p>很多人学不好进制，原因是总以十进制为依托去考虑其他进制，需要运算的时候也总是先转换成十进制，这种学习方法是错误的.<br>我们为什么一定要转换十进制呢？仅仅是因为我们对十进制最熟悉，所以才转换.<br>每一种进制都是完美的,想学好进制首先要忘掉十进制，也要忘掉进制间的转换！</p></blockquote><h3 id="进制的定义"><a href="#进制的定义" class="headerlink" title="进制的定义"></a>进制的定义</h3><ul><li>八进制由8个符号组成:0 1 2 3 4 5 6 7 逢八进一</li><li>十进制由10个符号组成:0 1 2 3 4 5 6 7 8 9逢十进一</li><li>N进制就是由N个符号组成:逢N进一</li></ul><h3 id="计算机中常见的数据宽度"><a href="#计算机中常见的数据宽度" class="headerlink" title="计算机中常见的数据宽度"></a>计算机中常见的数据宽度</h3><ul><li>位(Bit): 1个位就是1个二进制位.0或者1</li><li>字节(Byte): 1个字节由8个Bit组成(8位).内存中的最小单元Byte.</li><li>字(Word): 1个字由2个字节组成(16位),这2个字节分别称为高字节和低字节.</li><li>双字(Doubleword): 1个双字由两个字组成(32位)</li></ul><p>那么计算机存储数据它会分为有符号数和无符号数.那么关于这个看图就理解了!<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/20180323008.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无符号数,直接换算!</span><br><span class="line">有符号数:正数:  0    1    2    3    4    5    6    7 负数:  F    E    D    B    C    A    9    8      -1   -2   -3   -4   -5   -6   -7   -8</span><br></pre></td></tr></table></figure><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><strong>内部部件之间由总线连接</strong><br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/20180323009.jpg"></p><ul><li>对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制</li><li>不同的CPU，寄存器的个数、结构是不相同的</li></ul><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><ul><li><p>ARM64拥有有31个64位的通用寄存器 x0 到 x30,这些寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途）</p><ul><li>那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.</li><li><p>比如 w0 就是 x0的低32位!</p><p><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/20180323010.jpg"></p></li></ul></li><li><p>通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算</p></li><li><p>假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/20180323011.jpg"></p><ul><li>CPU首先会将红色内存空间的值放到X0寄存器中：mov X0,红色内存空间</li><li>然后让X0寄存器与1相加：add X0,1</li><li>最后将值赋值给内存空间：mov 蓝色内存空间,X0</li></ul></li></ul><h3 id="pc寄存器-program-counter"><a href="#pc寄存器-program-counter" class="headerlink" title="pc寄存器(program counter)"></a>pc寄存器(program counter)</h3><ul><li>为指令指针寄存器，它指示了CPU当前要读取指令的地址</li><li>在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息</li><li>CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义<ul><li>比如 1110 0000 0000 0011 0000 1000 1010 1010 </li><li>可以当做数据   0xE003008AA </li><li>也可以当做指令  mov    x0, x8</li></ul></li><li>CPU根据什么将内存中的信息看做指令？<ul><li>CPU将pc指向的内存单元的内容看做指令</li><li>如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过</li></ul></li></ul><h3 id="bl指令"><a href="#bl指令" class="headerlink" title="bl指令"></a>bl指令</h3><ul><li>CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令</li><li>ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如<ul><li>mov x0,#10、mov x1,#20</li></ul></li><li><p>但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能</p></li><li><p>ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在学习逆向开发之前,我们要了解一个基本的逆向原理.首先我们是逆向iOS系统上面的APP.那么我们知道,一个APP安装在手机上面的可执行文件本质上是二进制文件.因为iPhone手机本质上执行的指令是二进制.是由手机上的CPU执行的.所以逆向开发是建立在分析二进制上面.&lt;/
      
    
    </summary>
    
      <category term="安全攻防" scheme="https://liuliangju.github.io/categories/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="安全攻防" scheme="https://liuliangju.github.io/tags/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/"/>
    
  </entry>
  
  <entry>
    <title>第一篇：工具篇</title>
    <link href="https://liuliangju.github.io/2018/03/19/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/201803/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/"/>
    <id>https://liuliangju.github.io/2018/03/19/安全攻防/201803/安全攻防/</id>
    <published>2018-03-18T23:25:02.000Z</published>
    <updated>2018-04-26T14:26:10.007Z</updated>
    
    <content type="html"><![CDATA[<h4 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h4><p>&nbsp;&nbsp;上周去上海出差，被工行的人问到了解过代码混淆技术没，因为他们对安全性比较高，所以想对代码做下混淆，我一听，这不是<code>安全攻防</code>方面的知识吗，我做iOS开发也没接触过这方面的知识啊，所以回来赶紧上网查找资料，进行学习，也算是给无所事事的自己找点事做。</p><p>一开始以为做安全攻防必须需要一台越狱的手机设备，后来查找了很多资料，发现我错了，先说下学习环境吧：</p><ul><li>环境:<ul><li>Xcode 9.3</li><li>IDA7.0</li><li>hex fiend(16进制编辑器)</li></ul></li><li>硬件设备<ul><li>iPhone7(建议5s以上设备，5和5c以下为arm32位版本，5s以后为64位版本)</li></ul></li></ul><p>以上工具下载链接: <a href="https://pan.baidu.com/s/1ZWHKt3kai9OtdeYntzPlOA" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZWHKt3kai9OtdeYntzPlOA</a> 密码: iiwh</p><p>里面各个工具的作用不再详细阐述：<br><a href="https://baike.baidu.com/item/IDA%20Pro/3175923?fr=aladdin" target="_blank" rel="noopener">IDA Pro</a><br><code>ios-app-signer-master</code> 重签名使用</p><p>&nbsp;&nbsp;在查找工具的过程中，偶然发现了一个非越狱插件开发集成神器！<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a> 集成简单，堪称是一个神器。</p><h4 id="Cycript-安装"><a href="#Cycript-安装" class="headerlink" title="Cycript 安装"></a>Cycript 安装</h4><p>&nbsp;&nbsp;Cycript是一款脚本语言，可以看作是Objective-JavaScript，它可以帮助我们轻松测试和验证函数效果。</p><p>它的安装有多种方式</p><ol><li>使用apt-get安装：<ul><li>apt-get install cycript</li></ul></li><li>通过<a href="http://www.cycript.org/" target="_blank" rel="noopener">官网下载</a> <code>SDK</code> 安装</li></ol><h5 id="以下主要讲解通过第二种方式安装及可能遇到的问题："><a href="#以下主要讲解通过第二种方式安装及可能遇到的问题：" class="headerlink" title="以下主要讲解通过第二种方式安装及可能遇到的问题："></a>以下主要讲解通过第二种方式安装及可能遇到的问题：</h5><ol><li>在<a href="http://www.cycript.org/" target="_blank" rel="noopener">官网</a>将<code>cycript</code>下载到本地，然后解压得到 <code>cycript_0.9.594</code> 文件夹(cycript_0.9.594为当前我可下载的最新版本)</li><li><p>打开终端 输入 <code>cd /</code> 进入根目录，再输入 <code>la</code> 查看当前目录下的所有文件，会发现一个<code>opt</code>文件夹，下一步打开这个文件夹 <code>open opt</code> <img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/2018031901.png"></p></li><li><p>将刚才解压后的 <code>cycript_0.9.594</code> 文件夹 <code>copy</code> 到 <code>opt</code> 文件夹下</p></li><li>配置环境变量<br>进入终端，编辑<code>.base_profile</code>文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.bash_profile</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Cycript</span><br><span class="line">export CY_PATH_ROOT=/opt/cycript_0.9.594</span><br><span class="line">export PATH=$CY_PATH_ROOT:$PATH</span><br></pre></td></tr></table></figure><p>加入到 <code>.base_profile中</code><br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/2018031904.png"><br>点击 <code>esc</code> 退出编辑模式，输入<code>：+ wq!</code>，保存退出。</p><p>立即更新刚才修改的环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source .bash_profile</span><br></pre></td></tr></table></figure></p><p>如果使用<code>oh my zsh</code>，在<code>.zshrc</code>配置文件中也加入刚才配置的环境变量路径，这样每次打开就不用手动执行了！</p><p>大功告成，咱们照着官网的的命令操作一次，在终端中输入<code>cycript</code>，如果出现</p><p><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201803/2018031903.png"><br>环境配置成功。输入 <code>control + D</code> 即可退出 Cycript。</p><p>有时候结果并不像我们想的那么顺利，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyld: Library not loaded: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib</span><br><span class="line">Referenced from: /Users/liangju/Downloads/cycript_0.9.594/Cycript.lib/cycript-apl</span><br><span class="line">Reason: image not found</span><br></pre></td></tr></table></figure><p>经过上网查证，报错原因竟然是因为ruby版本太高</p><p><strong>本着出现问题就得解决的原则：</strong></p><h6 id="1-先查看下本地ruby版本"><a href="#1-先查看下本地ruby版本" class="headerlink" title="1.先查看下本地ruby版本"></a>1.先查看下本地<code>ruby</code>版本</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br></pre></td></tr></table></figure><p>结果：<code>ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin17]</code> 果然是版本太高，<code>Cycript</code>需要依赖 <code>ruby 2.0.0</code>版本，这时就想着怎么解决，要不然再装个 <code>ruby 2.0.0</code>的版本，用它装完 Cycript 我再把 ruby 版本改为 2.5.1，这么感觉不好，太麻烦。</p><h6 id="2-直接把本机的ruby版本的复制一份，改为2-0即可"><a href="#2-直接把本机的ruby版本的复制一份，改为2-0即可" class="headerlink" title="2.直接把本机的ruby版本的复制一份，改为2.0即可"></a>2.直接把本机的ruby版本的复制一份，改为2.0即可</h6><p> 既然 <code>Cycript</code>仅依赖<code>ruby 2.0.0</code>，那我直接把本机的ruby版本的复制一份，改为2.0不就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/</span><br><span class="line">sudo ln -s /System/Library/Frameworks/Ruby.framework/Versions/2.5/usr/lib/libruby.2.5.1.dylib /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>注：根据每个人ruby版本不同，将上面第二条命令的/System/Library/Frameworks/Ruby.framework/Versions/2.5.1/usr/lib/libruby.2.5.1.dylib中的2.5.1改成本机的ruby版本。</p></blockquote></blockquote><p>又遇到困难了，终端提示我没权限，不能操作。原来是<code>系统的SIP</code>搞得鬼。</p><h6 id="3-关闭系统的SIP"><a href="#3-关闭系统的SIP" class="headerlink" title="3.关闭系统的SIP"></a>3.关闭系统的SIP</h6><p>在 OS X El Capitan 中有一个跟安全相关的模式叫 SIP（System Integrity Protection ），它禁止让软件以 root 身份来在 Mac 上运行，在升级到 OS X 10.11 中或许你就会看到部分应用程序被禁用了，这些或许是你通过终端或者第三方软件源安装。</p><p>现在我们来关闭它：</p><ul><li><p>电脑重启，听到咚的时候，按住<code>command+R</code>，进入恢复模式</p></li><li><p>打开终端，输入<code>csrutil disable</code>，重启即可，然后重复步骤<code>2.把本机的ruby版本的复制一份，改为2.0</code>，然后再在终端运行</p></li><li><p>如果想打开SIP，重复上两步，命令改为<code>csrutil enable</code></p><p>现在再执行下<code>cycript</code>,终于大功告成。</p></li></ul><p>&nbsp;&nbsp;下一篇，正式进入安全攻防内容，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;工具篇&quot;&gt;&lt;a href=&quot;#工具篇&quot; class=&quot;headerlink&quot; title=&quot;工具篇&quot;&gt;&lt;/a&gt;工具篇&lt;/h4&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;上周去上海出差，被工行的人问到了解过代码混淆技术没，因为他们对安全性比较高，所以想对代码做下混淆，我一听，这
      
    
    </summary>
    
      <category term="安全攻防" scheme="https://liuliangju.github.io/categories/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/"/>
    
    
      <category term="安全攻防" scheme="https://liuliangju.github.io/tags/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/"/>
    
  </entry>
  
  <entry>
    <title>Swift 学习点滴记载(一)</title>
    <link href="https://liuliangju.github.io/2018/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A0%E7%82%B9%E6%BB%B4%E8%AE%B0%E8%BD%BD(%E4%B8%80)/"/>
    <id>https://liuliangju.github.io/2018/03/05/Swift学习/Swift学习点滴记载(一)/</id>
    <published>2018-03-05T14:22:22.000Z</published>
    <updated>2018-05-12T14:35:22.390Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Swift设置导航栏-navigationBar-背景颜色-标题颜色和字体大小-item颜色"><a href="#Swift设置导航栏-navigationBar-背景颜色-标题颜色和字体大小-item颜色" class="headerlink" title="Swift设置导航栏(navigationBar)背景颜色,标题颜色和字体大小,item颜色"></a>Swift设置导航栏(navigationBar)背景颜色,标题颜色和字体大小,item颜色</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    window = <span class="type">UIWindow</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">    window?.backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line">    <span class="keyword">let</span> nav = <span class="type">UINavigationController</span>(rootViewController: <span class="type">HomeVC</span>())</span><br><span class="line">    <span class="comment">//设置导航栏背景颜色</span></span><br><span class="line">    nav.navigationBar.barTintColor = <span class="type">UIColor</span>.blue</span><br><span class="line">    <span class="keyword">let</span> dict:<span class="type">NSDictionary</span> = [<span class="type">NSAttributedStringKey</span>.foregroundColor: <span class="type">UIColor</span>.white,<span class="type">NSAttributedStringKey</span>.font : <span class="type">UIFont</span>.boldSystemFont(ofSize: <span class="number">18</span>)]</span><br><span class="line">    <span class="comment">//标题颜色</span></span><br><span class="line">    nav.navigationBar.titleTextAttributes = dict <span class="keyword">as</span>? [<span class="type">NSAttributedStringKey</span> : <span class="type">AnyObject</span>]</span><br><span class="line">    <span class="comment">//item颜色</span></span><br><span class="line">    nav.navigationBar.tintColor = <span class="type">UIColor</span>.gray</span><br><span class="line">    window?.rootViewController = nav</span><br><span class="line">    window?.makeKeyAndVisible()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Swift按钮传参数方法定义"><a href="#Swift按钮传参数方法定义" class="headerlink" title="Swift按钮传参数方法定义"></a>Swift按钮传参数方法定义</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initLeftAndRightBarItem</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//        let button = UIButton(frame: CGRect(x: 100, y: 200, width: 100, height: 100))</span></span><br><span class="line"><span class="comment">//        button.addTarget(self, action: #selector(obclick(sender:)), for: .touchUpInside)</span></span><br><span class="line"><span class="comment">//        button.backgroundColor = UIColor.red</span></span><br><span class="line"><span class="comment">//        self.view.addSubview(button)</span></span><br><span class="line">        <span class="keyword">let</span> leftBarBtnItem = <span class="type">UIBarButtonItem</span>(image: <span class="type">UIImage</span>.<span class="keyword">init</span>(named: <span class="string">"tab_write"</span>), style: .done, target: <span class="keyword">self</span>, action: #selector(leftBtnClick(leftBarItem:)))</span><br><span class="line">        <span class="keyword">let</span> rightBarBtnItem = <span class="type">UIBarButtonItem</span>(image: <span class="type">UIImage</span>.<span class="keyword">init</span>(named:<span class="string">"actionsheet"</span>), style: .done, target: <span class="keyword">self</span>, action: #selector(rightBtnClick(rightBarItem:)))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.navigationItem.leftBarButtonItem = leftBarBtnItem</span><br><span class="line">        <span class="keyword">self</span>.navigationItem.rightBarButtonItem = rightBarBtnItem</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    @objc func obclick(sender:UIButton) &#123;</span></span><br><span class="line"><span class="comment">//        print(#function)</span></span><br><span class="line"><span class="comment">//        print("asdasdasd")</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">leftBtnClick</span><span class="params">(leftBarItem: UIBarButtonItem)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">rightBtnClick</span><span class="params">(rightBarItem: UIBarButtonItem)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Swift-中懒加载定义-tableView-两种不同的方法"><a href="#Swift-中懒加载定义-tableView-两种不同的方法" class="headerlink" title="Swift 中懒加载定义 tableView 两种不同的方法"></a>Swift 中懒加载定义 tableView 两种不同的方法</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> homeTableView = <span class="type">UITableView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: kNavHeight, width: kScreenWidth, height: kScreenHeight), style: .plain)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> secondTableView = &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UITableView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: kNavHeight, width: kScreenWidth, height: kScreenHeight), style: .plain)</span><br><span class="line">        &#125;()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Swift设置导航栏-navigationBar-背景颜色-标题颜色和字体大小-item颜色&quot;&gt;&lt;a href=&quot;#Swift设置导航栏-navigationBar-背景颜色-标题颜色和字体大小-item颜色&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Swift" scheme="https://liuliangju.github.io/categories/Swift/"/>
    
    
      <category term="Swift" scheme="https://liuliangju.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS基础知识点总结(二)</title>
    <link href="https://liuliangju.github.io/2018/02/23/iOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/201802/iOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>https://liuliangju.github.io/2018/02/23/iOS基础总结/201802/iOS基础知识点总结(二)/</id>
    <published>2018-02-22T22:42:54.000Z</published>
    <updated>2018-04-19T12:51:38.642Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、请简单说明多线程技术的优点和缺点？"><a href="#1、请简单说明多线程技术的优点和缺点？" class="headerlink" title="1、请简单说明多线程技术的优点和缺点？"></a>1、请简单说明多线程技术的优点和缺点？</h4><p><code>优点</code></p><ul><li>能够适当提高程序的执行效率；</li><li>能够适当的提高资源的利用率，比如CPU、内存。</li></ul><p><code>缺点</code></p><ul><li>创建线程有额外开销</li><li>程序的代码更加复杂</li><li>线程越多，CPU在调度线程上的开销就越大</li><li>如果开启大量线程，反而会降低程序的性能</li></ul><h4 id="2、请简单介绍下什么是原子和非原子属性？"><a href="#2、请简单介绍下什么是原子和非原子属性？" class="headerlink" title="2、请简单介绍下什么是原子和非原子属性？"></a>2、请简单介绍下什么是原子和非原子属性？</h4><ul><li>atomic：原子属性，会为setter方法加锁，默认为atomic。线程安全，会消耗大量资源</li><li>nonatomic：非原子属性，不会为setter方法加锁。非线程安全，适合内存小的移动设备。</li></ul><h4 id="3、请简单说明对图片进行二级缓存的实现思路？"><a href="#3、请简单说明对图片进行二级缓存的实现思路？" class="headerlink" title="3、请简单说明对图片进行二级缓存的实现思路？"></a>3、请简单说明对图片进行二级缓存的实现思路？</h4><p><code>在显示图片的时候</code></p><ul><li>1.先检查该图片对应的内存缓存<ul><li>1.如果存在内存缓存，则<br> a.直接使用设置并显示图片；</li></ul><ul><li>2.如果内存缓存中没有,则<br>a.继续检查该图片对应的磁盘缓存是否存在，跳转到第2步。</li></ul></li><li>2.检查该图片对应的磁盘缓存<ul><li>1.如果存在磁盘缓存，则<br>a.先保存一份到内存缓存中（方便下次使用）<br>b.然后设置并显示图片</li><li>2.如果不存在磁盘缓存，则直接下载该图片，下载完成后<br>a.保存一份到内存缓存中<br>b.保存一份到磁盘缓存中<br>c.设置并显示图片</li></ul></li></ul><h4 id="4、请简单说明NSCache的特点？"><a href="#4、请简单说明NSCache的特点？" class="headerlink" title="4、请简单说明NSCache的特点？"></a>4、请简单说明NSCache的特点？</h4><ul><li>NSCache是苹果推出专门用来处理内存缓存的类</li><li>NSCache默认是线程安全的,在使用的时候可以不用考虑线程安全的问题</li><li>NSCache使用方法和可变字典类似,当缓存文件超过最大限度的时候会开启一个回收过程,把最老的缓存对象回收</li><li>NSCache可以设置缓存的const(成本)和缓存的数量</li></ul><h4 id="5、请问SDWebImage框架的框架结构是怎么样的？"><a href="#5、请问SDWebImage框架的框架结构是怎么样的？" class="headerlink" title="5、请问SDWebImage框架的框架结构是怎么样的？"></a>5、请问SDWebImage框架的框架结构是怎么样的？</h4><p>SDWebImage框架有几个主要的组件：</p><ul><li>管理者（SDWebImageManager)</li><li>缓存处理组件（SDImageCache）主要对下载的图片进行内存缓存和磁盘缓存处理</li><li>下载处理组件（SDWebImageDownloader|SDWebImageDownloadOperation）主要处理开子线程异步发送网络请求下载图片相关操作</li></ul><h4 id="6、请简单说明GET请求和POST个请求有什么区别-如何选择？"><a href="#6、请简单说明GET请求和POST个请求有什么区别-如何选择？" class="headerlink" title="6、请简单说明GET请求和POST个请求有什么区别,如何选择？"></a>6、请简单说明GET请求和POST个请求有什么区别,如何选择？</h4><ul><li>GET请求的参数直接用&amp;拼接并以？为分隔拼接在请求URL的后面</li><li>POST请求的参数是转换为二进制设置在请求体传递的</li><li>如果仅仅只是索取数据获得数据，那么建议使用GET请求，其他情况则建议使用POST请求，相对而言POST请求安全性更好一些。</li></ul><h4 id="7、请简单列出使用NSURLConnection发送一个异步POST网络请求的步骤"><a href="#7、请简单列出使用NSURLConnection发送一个异步POST网络请求的步骤" class="headerlink" title="7、请简单列出使用NSURLConnection发送一个异步POST网络请求的步骤?"></a>7、请简单列出使用NSURLConnection发送一个异步POST网络请求的步骤?</h4><ul><li>1.确定请求路径（URL）</li><li>2.创建可变的请求对象（NSMutableURLRequest）</li><li>3.修改请求方法为POST请求</li><li>4.把参数拼接起来转换为二进制数据，设置请求体</li><li>5.使用NSURLConnection发送异步请求([NSURLConnection sendAsync….])</li><li>6.解析服务器返回的数据，查看请求结果</li></ul><h4 id="8、请简单介绍下AFN各个主要版本的情况？"><a href="#8、请简单介绍下AFN各个主要版本的情况？" class="headerlink" title="8、请简单介绍下AFN各个主要版本的情况？"></a>8、请简单介绍下AFN各个主要版本的情况？</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>.<span class="number">1</span>--<span class="number">1.0</span>            <span class="string">"2.0---2.6.3"</span>                      <span class="number">3.0</span>--&gt;<span class="number">3.1</span>.<span class="number">0</span></span><br><span class="line">NSURLConnection   - (NSURLConnection + NSURLSession)  - NSURLSession</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>.<span class="number">1</span>-<span class="number">2.0</span>  NSURLConnection</span><br><span class="line"><span class="number">2.0</span> -<span class="number">3.0</span> NSURLSession + NSURLConnection</span><br><span class="line"><span class="number">3.0</span> + NSURLSession</span><br></pre></td></tr></table></figure><h4 id="9、在使用NSURLSession进行文件上传的时候，如何监听文件上传的进度，有哪些注意点？"><a href="#9、在使用NSURLSession进行文件上传的时候，如何监听文件上传的进度，有哪些注意点？" class="headerlink" title="9、在使用NSURLSession进行文件上传的时候，如何监听文件上传的进度，有哪些注意点？"></a>9、在使用NSURLSession进行文件上传的时候，如何监听文件上传的进度，有哪些注意点？</h4><ul><li>创建会话对象的时候，需要设置代理，让控制器成为session的代理</li><li>遵守代理协议（NSURLSessionDataDelegate）</li><li>实现代理方法，在代理方法中计算文件的上传进度<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  - (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">               task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">    didSendBodyData:(int64_t)bytesSent</span><br><span class="line">     totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br></pre></td></tr></table></figure></li></ul><p>注意：当任务执行完毕的时候应该释放对代理对象的强引用</p><h4 id="10、在发送网络请求的时候，如果一个参数（place）需要对应着多个值，那么以下两种请求路径哪种是正确的？"><a href="#10、在发送网络请求的时候，如果一个参数（place）需要对应着多个值，那么以下两种请求路径哪种是正确的？" class="headerlink" title="10、在发送网络请求的时候，如果一个参数（place）需要对应着多个值，那么以下两种请求路径哪种是正确的？"></a>10、在发送网络请求的时候，如果一个参数（place）需要对应着多个值，那么以下两种请求路径哪种是正确的？</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①<span class="symbol">:</span>[<span class="symbol">http:</span>/<span class="regexp">/192.168.31.520:1314/loveyou</span>?place=Beijing&amp;Shanghai](<span class="symbol">http:</span>/<span class="regexp">/120.25.226.186:32812/weather</span>?place=Beijing&amp;Shanghai)</span><br><span class="line"></span><br><span class="line">②<span class="symbol">:</span>[<span class="symbol">http:</span>/<span class="regexp">/](http:/</span><span class="regexp">/120.25.226.186:32812/weather</span>?place=Beijing&amp;place=Shanghai)[<span class="number">192.168</span>.<span class="number">31.520</span><span class="symbol">:</span><span class="number">1314</span>](<span class="symbol">http:</span>/<span class="regexp">/120.25.226.186:32812/weather</span>?place=Beijing&amp;Shanghai)/loveyou?place=Beijing&amp;place=Shanghai</span><br></pre></td></tr></table></figure><p>第二种请求路径是正确的，第一种是错误的，后面的shanghai将会被忽略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、请简单说明多线程技术的优点和缺点？&quot;&gt;&lt;a href=&quot;#1、请简单说明多线程技术的优点和缺点？&quot; class=&quot;headerlink&quot; title=&quot;1、请简单说明多线程技术的优点和缺点？&quot;&gt;&lt;/a&gt;1、请简单说明多线程技术的优点和缺点？&lt;/h4&gt;&lt;p&gt;&lt;c
      
    
    </summary>
    
      <category term="iOS基础" scheme="https://liuliangju.github.io/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="iOS" scheme="https://liuliangju.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS基础知识点总结(一)</title>
    <link href="https://liuliangju.github.io/2018/02/05/iOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/201802/iOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
    <id>https://liuliangju.github.io/2018/02/05/iOS基础总结/201802/iOS基础知识点总结(一)/</id>
    <published>2018-02-05T14:22:22.000Z</published>
    <updated>2018-04-19T12:51:38.641Z</updated>
    
    <content type="html"><![CDATA[<p>以下是一些自己收集的比较基础的面试问题（大神可以忽略）附上答案，毕竟个人水平有限难免会有些错误或回答的局限性，如果发现错误也欢迎大家指出，一起探讨进步。</p><h4 id="1、-import和-include的区别-class代表什么"><a href="#1、-import和-include的区别-class代表什么" class="headerlink" title="1、#import和#include的区别,@class代表什么"></a>1、#import和#include的区别,@class代表什么</h4><ul><li><code>import</code>会包含这个类的所有信息，包含实体变量和方法(.h文件中)，而<code>@class</code>只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，后面会再告诉你。</li><li><code>#import</code>比起<code>#include</code>的好处是不会引起交叉编译，也就是常说的重复包含。<br></li></ul><p>注：<code>#import</code> 就是把被引用类的头文件都走一遍，即把<code>.h</code>文件里的变量和方法都包含进来一次，且仅一次，而<code>@class</code>不用，所以后者编译效率更高。</p><h4 id="2、控制器的生命周期"><a href="#2、控制器的生命周期" class="headerlink" title="2、控制器的生命周期"></a>2、控制器的生命周期</h4><ul><li>initWithCoder:(NSCoder *)aDecoder：（如果使用storyboard或者xib）</li><li>loadView：加载view</li><li>viewDidLoad：view加载完毕</li><li>viewWillAppear：控制器的view将要显示</li><li>viewWillLayoutSubviews：控制器的view将要布局子控件</li><li>viewDidLayoutSubviews：控制器的view布局子控件完成<br><code>这期间系统可能会多次调用viewWillLayoutSubviews 、 viewDidLayoutSubviews</code></li><li>viewDidAppear：控制器的view完全显示</li><li>viewWillDisappear：控制器的view即将消失</li><li>viewDidDisappear：控制器的view完全消失</li></ul><p><a href="https://www.jianshu.com/p/a5f82922e387" target="_blank" rel="noopener">loadView方法:</a></p><table class="table table-bordered table-condensed"><tr><td bgcolor="Gainsboro">当我们用到控制器view的时候，就会调用控制器view的get方法，在get方法内部，首先判断view是否已经被创建，如果已经存在，则直接返回存在的view，如果不存在，则会调用控制器的loadView方法，在控制器没有被销毁的情况下，loadView也可能会被执行多次<br></td></tr></table><br><table class="table table-bordered table-condensed"><tr><td bgcolor="Gainsboro"><strong>小结：</strong>控制器view的生命周期：loadView -&gt; viewDidLoad -&gt; viewWillAppear -&gt; viewWillLayoutSubviews -&gt; viewDidLayoutSubviews<br>-&gt; viewDidAppear -&gt; viewWillDisappear -&gt; viewDidDisappear<br></td></tr></table><h4 id="3、导航push做了哪些事情"><a href="#3、导航push做了哪些事情" class="headerlink" title="3、导航push做了哪些事情"></a>3、导航push做了哪些事情</h4><ul><li>当调用push方法时, 会把要push的控制器添加到导航控制器管理的栈中,把之前导航控制器中栈顶控制器View给移除,把当前栈顶控制器添加上去</li></ul><h4 id="4、导航pop做了哪些事情"><a href="#4、导航pop做了哪些事情" class="headerlink" title="4、导航pop做了哪些事情"></a>4、导航pop做了哪些事情</h4><ul><li>当调用pop方法的时候，会把要pop的控制器从栈里移除，把之前导航控制器中栈顶控制器的view移除，把当前栈顶控制器添加上去</li></ul><h4 id="5、frame-和-bounds-的区别是什么？"><a href="#5、frame-和-bounds-的区别是什么？" class="headerlink" title="5、frame 和 bounds 的区别是什么？"></a>5、frame 和 bounds 的区别是什么？</h4><ul><li>frame相对于父视图,是父视图坐标系下的位置和大小。bounds相对于自身,是自身坐标系下的位置和大小。</li><li>frame以父控件的左上角为坐标原点，bounds以自身的左上角为坐标原点</li></ul><h4 id="6、-load-和-initialize-的区别是什么"><a href="#6、-load-和-initialize-的区别是什么" class="headerlink" title="6、+load 和 +initialize 的区别是什么"></a>6、+load 和 +initialize 的区别是什么</h4><ul><li>+(void)load;<br>&emsp;当类对象被引入到项目时，runtime会向每个一个类对象发送load消息，load方法会在每一个类甚至分类被引入时仅调用一次，调用的顺序：父类优先于子类，子类优先于分类</li><li>+(void)initialize;<br>&emsp;第一次使用这个类的时候会调用这个方法</li></ul><h4 id="7、如何为Class定义一个对外只读对内可读写的属性"><a href="#7、如何为Class定义一个对外只读对内可读写的属性" class="headerlink" title="7、如何为Class定义一个对外只读对内可读写的属性"></a>7、如何为Class定义一个对外只读对内可读写的属性</h4><ul><li>在头文件中将属性定义为<code>readonly</code>，在<code>.m</code>文件中将属性重新定义为<code>readwrite</code></li></ul><h4 id="8、strong-weak-unsafe-unretained的区别"><a href="#8、strong-weak-unsafe-unretained的区别" class="headerlink" title="8、strong / weak / unsafe_unretained的区别"></a>8、strong / weak / unsafe_unretained的区别</h4><ul><li>weak只能修饰OC对象，使用weak不会使引用计数加1，对象销毁时修饰的对象会指向nil</li><li>strong等价于retain，能使计数器加1，且不能用来修饰数据类型</li><li>unsafe_unretained等价于assign，可以用来修饰数据类型和OC对象，但是不会使计数器加1，且对象销毁时也不会将对象指向nil，容易造成野指针错误。</li></ul><h4 id="9、iOS-的沙盒目录结构是怎样的"><a href="#9、iOS-的沙盒目录结构是怎样的" class="headerlink" title="9、iOS 的沙盒目录结构是怎样的"></a>9、iOS 的沙盒目录结构是怎样的</h4><ul><li>Application:存放程序源文件，上架前经过数字签名，上架后不可修改</li><li>Documents:常用目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。</li><li>Library<ul><li>Caches：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。</li><li>Preference：iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好.</li></ul></li><li>tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。该路径下的文件不会被iTunes备份。</li></ul><h4 id="10、通过代码如何自定义控件-并且简单的描述下每一个步骤的理由"><a href="#10、通过代码如何自定义控件-并且简单的描述下每一个步骤的理由" class="headerlink" title="10、通过代码如何自定义控件? 并且简单的描述下每一个步骤的理由?"></a>10、通过代码如何自定义控件? 并且简单的描述下每一个步骤的理由?</h4><ul><li>新建一个继承<code>UIView</code>的子类(所谓自定义控件就是继承系统自带的控件写一个适合自己项目特殊需求的控件)</li><li>在<code>initWithFrame</code>方法中添加子控件(保证别人在其他类不管是通过<code>init</code>还是通过<code>initWithFrame</code>创建都能够添加子控件，因为init方法内部会调用initWithFrame)</li><li>在<code>layoutSubViews</code>方法中设置子控件的frame(在<code>initWithFrame</code>方法中当前的控件可能没值，所以计算不了子控件的位置和尺寸，而在<code>layoutSubViews</code>方法中，能够拿到当前控件的尺寸)</li><li>提供一个模型属性，重写模型属性的<code>set</code>方法</li></ul><h4 id="11、简单的描述下类扩展-extension-和分类-category-的区别"><a href="#11、简单的描述下类扩展-extension-和分类-category-的区别" class="headerlink" title="11、简单的描述下类扩展(extension)和分类(category)的区别?"></a>11、简单的描述下类扩展(extension)和分类(category)的区别?</h4><ul><li>类扩展(也被称作匿名分类)没有名字，分类有名字</li><li>类扩展中新添加的方法必须要实现，分类可以不实现</li><li>类扩展是分类的一个特例，可以为一个类添加一些私有成员变量和方法，分类可以在不修改原来类的基础上，为一个类添加类扩展方法，一般用于给系统自带的类扩展方法，不能添加成员变量，如果一定要添加，可以通过<code>runtime</code>实现</li></ul><h4 id="12、Objective-C-如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能"><a href="#12、Objective-C-如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能" class="headerlink" title="12、Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能"></a>12、Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能</h4><ul><li>主要考察的是<code>runtime</code>如何交换方法<br></li></ul><p>实现：<br>1，先在分类中添加一个方法，注意不能重写系统方法，否则会被覆盖<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)p_printLog &#123;</span><br><span class="line">    <span class="comment">// 这里写打印行号,什么方法,哪个类调用等等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2，交换方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载分类到内存到时候调用</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="comment">// 获取系统的描述方法</span></span><br><span class="line">    Method description = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(description));</span><br><span class="line">    <span class="comment">// 自定义的打印日志方法</span></span><br><span class="line">    Method myLog = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(p_printLog));</span><br><span class="line">    <span class="comment">// 交换方法</span></span><br><span class="line">    method_exchangeImplementations(description, myLog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="13、如何让-Category-支持属性"><a href="#13、如何让-Category-支持属性" class="headerlink" title="13、如何让 Category 支持属性"></a>13、如何让 Category 支持属性</h4><ul><li>使用<code>runtime</code>实现</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">LJTest</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *testName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *kIdentifier = <span class="string">"testName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">LJTest</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)testName &#123;</span><br><span class="line">    <span class="comment">// 根据关联的 kIdentifier, 获取关联的值</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, kIdentifier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTestName:(<span class="built_in">NSString</span> *)testName &#123;</span><br><span class="line">    <span class="comment">// 第一个参数：给哪个对象添加关联</span></span><br><span class="line">    <span class="comment">// 第二个参数：关联的key，通过这个key获取</span></span><br><span class="line">    <span class="comment">// 第三个参数：关联的value</span></span><br><span class="line">    <span class="comment">// 第四个参数:关联的策略</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kIdentifier, testName, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14、iOS-assign，weak，strong，copy，-atomic，-nonatomic-使用场景"><a href="#14、iOS-assign，weak，strong，copy，-atomic，-nonatomic-使用场景" class="headerlink" title="14、iOS assign，weak，strong，copy， atomic， nonatomic 使用场景"></a>14、iOS assign，weak，strong，copy， atomic， nonatomic 使用场景</h4><p><strong>assign 与 weak区别</strong></p><ul><li><code>assign</code> 适用于基本数据类型，<code>weak</code>适用于<code>NSObject</code>对象，并且是一个弱引用，<code>assign</code>其实也可以用来修饰对象，那么我们为什么不用它修饰对象呢？因为被<code>assign</code>修饰的对象(一般编译的时候会产生警告：Assigning retained object to unsafe property; object will be released after assignment)在释放之后，指针的地址还是存在的，也就是说指针并没有被置为<code>nil</code>，造成野指针，对象一般分配在堆上的某块内存内存上，如果在后续的内存分配中，恰巧分到了这块地址，程序就会崩掉</li><li>为什么可以用<code>assign</code>修饰基本数据类型呢？因为基础数据类型一般分配在栈上，栈的内存会由系统自动处理，不会造成野指针。<code>weak</code>修饰的对象在释放之后，指针地址会被置为<code>nil</code>，所以在一般弱引用使用weak修饰</li><li><code>weak</code>使用场景：在ARC，在有可能出现循环引用的时候，往往要通过让其中的一端使用weak来解决，常见的比如：delegate属性，通常就会声明为weak。自身已经对它进行一次强引用，没有必要再强引用一次时也会使用weak。</li></ul><p><strong>strong 与 copy区别</strong></p><ul><li><code>strong</code>与<code>copy</code>都会使引用计数(retain)加1，但<code>strong</code>是两个指针指向同一块地址，copy会在内存里拷贝一份对象，两个指针指向不同的内存地址</li></ul><p><strong><strong>block 与 </strong>weak区别</strong></p><ul><li><code>__block</code>用来修饰一个变量，这个变量在block代码块中，如果想被修改，则需要使用<code>__block</code>修饰，使用使用 <code>__block</code>修饰的变量在block代码块中会被retain（ARC下会retain，MRC下不会retain）<strong>weak：使用</strong>weak修饰的变量不会在block代码块中被retain，同时，在ARC下，要避免block出现循环引用 __weak typedof(self)weakSelf = self;</li></ul><p><strong>nonatomic 与 atomic区别</strong></p><ul><li><code>atomic</code>的意思就是setter/getter这两个函数的一个原语操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样。 nonatomic不保证setter/getter的原语行，所以你可能会取到不完整的东西。 比如setter函数里面改变两个成员变量，如果你用nonatomic的话，getter可能会取到只更改了其中一个变量时候的状态。 atomic是线程安全的,nonatomic是线程不安全的。如果只是单线程操作的话用nonatomic最好,因为后者效率高一些</li></ul><h4 id="15、对NSUserDefaults的理解"><a href="#15、对NSUserDefaults的理解" class="headerlink" title="15、对NSUserDefaults的理解"></a>15、对NSUserDefaults的理解</h4><ul><li><code>NSUserDefaults</code>是系统提供的一种存储数据的方式，主要用于保存少量的数据，默认存储到library下的Preferences文件夹</li></ul><h4 id="16、LoadView-作用以及使用LoadView的注意点"><a href="#16、LoadView-作用以及使用LoadView的注意点" class="headerlink" title="16、LoadView 作用以及使用LoadView的注意点?"></a>16、LoadView 作用以及使用LoadView的注意点?</h4><p>控制器调用loadView方法创建控制器的view.它默认的做法是：</p><ul><li>先去判断当前控制器是不是从<code>StoryBoard</code>当中加载的，如果是，那么他就会从<code>StoryBoard</code>当中加载控制器的View.</li><li>如果不是从<code>StoryBoard</code>当中加载的，那么他会从<code>Xib</code>加载控制器的View.</li><li>如果也不是从Xib加载的控制器，那么他就会创建一个空的UIView，设为当前控制器的View.<br><strong>注意：</strong></li><li>一旦重写了<code>loadView</code>，表示需要自己创建控制器的View。</li><li>如果控制器的View还没有赋值，就不能调用控制器的View的get方法，会造成死循环，因为控制器View的个体方法底层会调用loadView方法.</li></ul><p>最后附pdf版本查看链接：<a href="https://github.com/liuliangju/liuliangju.github.io/raw/master/docs/20180207001.pdf" target="_blank" rel="noopener">iOS基础知识点总结(一).pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是一些自己收集的比较基础的面试问题（大神可以忽略）附上答案，毕竟个人水平有限难免会有些错误或回答的局限性，如果发现错误也欢迎大家指出，一起探讨进步。&lt;/p&gt;
&lt;h4 id=&quot;1、-import和-include的区别-class代表什么&quot;&gt;&lt;a href=&quot;#1、-im
      
    
    </summary>
    
      <category term="iOS基础" scheme="https://liuliangju.github.io/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="iOS" scheme="https://liuliangju.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS多工程依赖</title>
    <link href="https://liuliangju.github.io/2016/12/25/iOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/2018%E4%B9%8B%E5%89%8D/iOS%E5%A4%9A%E5%B7%A5%E7%A8%8B%E4%BE%9D%E8%B5%96/"/>
    <id>https://liuliangju.github.io/2016/12/25/iOS基础总结/2018之前/iOS多工程依赖/</id>
    <published>2016-12-25T13:04:32.000Z</published>
    <updated>2018-04-19T12:51:38.642Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在日常开发中，有时候我们为了保持整个项目的结构清晰，需要对项目的不同的类进行模块化，其中使用工程依赖是个不错的选择。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>1，新建一个workspace工程，我创建了一个TestDemo工程然后引入cocoapods.<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201612/201612251.png"><br>2，然后新建一个静态库工程，建立方法<code>Framework &amp; Library-&gt;Cocoa Touch Static Library</code>取名为<code>LJCommonUI</code>，<font color="purple"><i>注意：这个静态库工程与第一个工程分开创建</i></font><br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201612/201612252.png"><br>3，将<code>LJCommonUI</code>拖进基础工程的文件夹<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201612/201612253.png"> </p><h4 id="建立相关引用"><a href="#建立相关引用" class="headerlink" title="建立相关引用"></a>建立相关引用</h4><p>1，打开基础工程，Add Files to…，把<code>LJCommonUI</code>引入<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201612/201612254.png"><br>添加完如下图<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201612/201612255.png"><br>2，设置Header Path, Build Setting-Header Search Paths   (添加头文件搜索路径)<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201612/201612256.png"><br>3，引入.a文件, Build Phases - Link Binary With Libraries 添加LJCommonUI.a<br><img src="https://github.com/liuliangju/liuliangju.github.io/raw/master/blogImg/201612/201612257.png"><br>注意：<br>1，如果<code>LJCommonUI</code>里面有图片或者其他的依赖库<br>B-Build Phases - Copy Files添加对应的图片和依赖库<br>2，如果<code>LJCommonUI</code>里有category，使用category的时候会crash<br>B-Other Linker Flags 添加<code>-Objc</code>和<code>-all_load</code>确保category被正常引入</p><h4 id="打包注意事项"><a href="#打包注意事项" class="headerlink" title="打包注意事项"></a>打包注意事项</h4><p>有依赖库的时候，Archive通常在organize里找不到项目或者没有version和identifier<br>要把依赖库LJCommonUI - Build Settings - Skip Install设置为YES，但项目TestDemo - Skip Install设置为NO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在日常开发中，有时候我们为了保持整个项目的结构清晰，需要对项目的不同的类进行模块化，其中使用工程依赖是个不错的选择。&lt;/p&gt;
&lt;h4 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;
      
    
    </summary>
    
      <category term="技术" scheme="https://liuliangju.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://liuliangju.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS文件统一管理</title>
    <link href="https://liuliangju.github.io/2016/12/10/iOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/2018%E4%B9%8B%E5%89%8D/iOS%E6%96%87%E4%BB%B6%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86/"/>
    <id>https://liuliangju.github.io/2016/12/10/iOS基础总结/2018之前/iOS文件统一管理/</id>
    <published>2016-12-09T22:45:30.000Z</published>
    <updated>2018-04-19T12:51:38.642Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近在做我们公司自己的项目时，遇到了一个难题，就是随着用户使用我们公司的app时间越久，便导致app沙盒文件越来越多，严重时我查看我们公司的app使用内存量达到了<code>7.3G</code>，查看方式，打开你的苹果手机,(<code>设置-通用-储存空间及iCloud用量-管理储存空间</code>);怎么样不查不知道一查是不是吓一跳？<br>&emsp;&emsp;细说下我们公司app占用内存量大的原因，我们公司的app属于类社交和OA类，其中有类似微信的朋友圈和聊天，及收藏功能，所以当用户发图片很多时，图片都存入自己的沙盒中，当用户在聊天页面点击图片收藏，图片会复制一份并生成新的图片再次上传服务器，同时新生成的图片也会copy到我们已经规定好的沙盒中的收藏文件夹(之所以给每个模块都在沙盒目录中规定一个文件夹，为了便于清理,注：每个聊天会话的图片都存在它特定的文件夹下，删除某一条会话时，会话下的图片也能得到及时清除)下。同理，在朋友圈中的图片也可以收藏。所以当图片少的时候暂时没有发现问题，而且似乎感觉还很好，因为每次文件清理直接拿到每一个模块的路径文件夹清理就可以。然而，随着时间的推移，用户选择的文件的越来越多，便产生一开始描述的问题。附路径地址：<br><span style="margin-top:-48px"><table class="table table-bordered table-condensed"><tr><td bgcolor="Gainsboro">/Users/liangju/Library/Developer/CoreSimulator/Devices/6184D61E-A799-4127-881E-F71E3D9CD61B/data/Containers/Data/Application/F83F1BC6-4809-40B9-80EC-D1EC7FEF2FBA/Documents/my_app/1BdWrWKyJ8MUpM7ofJsa4g/file/CC_OPEN_MESSAGE/<br>g_2BwfR0iZJedUvP6ispaOAp/168D8A9C8830461AAC6C6711C9136115.jpg</td></tr></table><br> <table style="margin-top:-36px" class="table table-bordered table-condensed"><tr><td bgcolor="Gainsboro">/Users/liangju/Library/Developer/CoreSimulator/Devices/6184D61E-A799-4127-881E-F71E3D9CD61B/data/Containers/Data/Application/F83F1BC6-4809-40B9-80EC-D1EC7FEF2FBA/Documents/my_app/1BdWrWKyJ8MUpM7ofJsa4g/file/CC_OPEN_MESSAGE/<br> u_2aRr2i4UF5dkXExQMVTly1I/317C7D7B10D847B09F4CE827BC8EB78F.jpg<br></td></tr></table>其中地址中my_app 为app名字，1BdWrWKyJ8MUpM7ofJsa4g为登录人id，CC_OPEN_MESSAGE为服务id，也就是下文中的SERV_ID，u_2aRr2i4UF5dkXExQMVTly1I为绘画id，其中我们公司规定以u开头是单人绘画，g开头为群组绘画，同时此项也就是下文中的DATA_ID，再往下就是image对象名字了</span><br>&emsp;&emsp;所以便想能不能把这些文件统一管理起来，比如聊天中的图片再收藏时(前提此图片已经上传服务器成功，上传失败的情况我们稍后讨论)，能不能不在复制产生新的图片上传，收藏模块的图片直接去聊天的那张图片路径下，把这张图片读出显示。<br>&emsp;&emsp;实现篇:统一封住文件最终下载所调的接口。每个文件下载时都给它固定了一个下载路径。当它下载成功后，把文件对应的服务器的文件id，保存到数据表中。结合每个公司的不同情况合理设置缓存模型，我们公司的设置如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件在服务端的id </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *SERVER_FILEID;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能分类:例如：在聊天中就是CC_OPEN_MESSAGE</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *SERV_ID;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在chat功能中就是msgId</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *DATA_ID;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件长度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *FILE_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待定：数据创建时间</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *S_ATIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待定：数据创建时间</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *S_MTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地相对路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *PATH;</span><br></pre></td></tr></table></figure><p>其次在每次下载图片的时候，1，先从sd内存缓存里读出图片，若读出直接block image对象；2，若不存在image，则需要先根据SERVER_FILEID查一下本地是否已经存在那条数据，如果存在，根据路径读出图片，再根据SERV_ID、DATA_ID、SERVER_FILEID再次查找本地表是否存在这条数据，如果不存在，则新建一条数据；当根据SERVER_FILEID在本地表中查找不到时，继续往下走，调用图片下载方法(我们采用的图片下载三方为sd),以下为相关代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)rh_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock rhImgParam:(RHImageParam *)rhImgParam &#123;</span><br><span class="line">    <span class="comment">//modify</span></span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dict = [RHFileCacheHelper getServeFileIdAndImageSizeWithServerUrl:url];</span><br><span class="line">    <span class="built_in">NSString</span> *fileId = dict[<span class="string">@"FIELD"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *image_size = dict[<span class="string">@"IMG_SIZE"</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *paramDict = rhImgParam.extraDict;</span><br><span class="line">    <span class="built_in">NSString</span> *serv_Id = paramDict ? paramDict[<span class="string">@"SERV_ID"</span>] : <span class="string">@""</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *data_Id = paramDict ? paramDict[<span class="string">@"DATA_ID"</span>] : <span class="string">@""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rhImgParam.category) &#123;</span><br><span class="line">        url = [[RHWebImageManager sharedManager] changeURL:url param:rhImgParam];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0 表示未传值 (默认)</span></span><br><span class="line">    <span class="keyword">if</span> (options == <span class="number">0</span> || ((options &amp; SDWebImageRefreshCached) != SDWebImageRefreshCached)) &#123; <span class="comment">// 1，内存缓存读出图片</span></span><br><span class="line">        <span class="built_in">NSString</span> *key = [rhImgParam.manager cacheKeyForURL:url];</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [rhImgParam.manager.imageCache imageFromDiskCacheForKey:key];</span><br><span class="line">        <span class="keyword">if</span> (image) &#123;</span><br><span class="line">            <span class="keyword">self</span>.image = image;</span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                completedBlock(image, <span class="literal">nil</span>, SDImageCacheTypeMemory, url);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2，从缓存表中读出图片</span></span><br><span class="line">            <span class="keyword">if</span> ([image_size integerValue] &gt; <span class="number">300</span>) &#123;</span><br><span class="line">                image = [RHFileCacheHelper fetchSqlCacheImageWithServId:serv_Id dataId:data_Id serFileId:fileId];</span><br><span class="line">                <span class="keyword">if</span> (image) &#123; <span class="comment">// servId dataId servFileId</span></span><br><span class="line">                    <span class="keyword">self</span>.image = image;</span><br><span class="line">                    <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                        completedBlock(image, <span class="literal">nil</span>, SDImageCacheTypeDisk, url);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> rh_cancelCurrentImageLoad];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="keyword">self</span>.image = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">//        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span></span><br><span class="line">    <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [rhImgParam.manager downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                    wself.image = image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                    <span class="keyword">if</span> (([image_size integerValue] &gt; <span class="number">300</span>) &amp;&amp; image) &#123; <span class="comment">// 保存图片到缓表的操作</span></span><br><span class="line">                        <span class="built_in">NSString</span> *fileName = [RHTools cachedFileNameForKey:url.absoluteString param:rhImgParam];</span><br><span class="line">                        <span class="built_in">NSString</span> *fullPath = [RHCommonHelper getCacheFileFullPathWithServID:serv_Id dataId:data_Id imageId:fileName];</span><br><span class="line">                        <span class="built_in">NSInteger</span> length = [<span class="built_in">UIImageJPEGRepresentation</span>(image,<span class="number">1</span>) length];</span><br><span class="line">                        RHFileCacheModel *fileModel = [RHFileCacheHelper getFileCacheModelWithServ_Id:serv_Id dataId:data_Id server_FileId:fileId fileLocalFullPath:fullPath fileSize:([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, (<span class="keyword">long</span>)length])];</span><br><span class="line">                        [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself.image = placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据servId、dataId，serFileId读出混存表中的图片</span></span><br><span class="line"><span class="comment"> * @param servId 服务id</span></span><br><span class="line"><span class="comment"> * @param dataId dataid</span></span><br><span class="line"><span class="comment"> * @param serFileId 服务端文件id</span></span><br><span class="line"><span class="comment"> * @return image对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)fetchSqlCacheImageWithServId:(<span class="built_in">NSString</span> *)servId dataId:(<span class="built_in">NSString</span> *)dataId serFileId:(<span class="built_in">NSString</span> *)serFileId &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *fileArray = [[RHFileCacheManager sharedInstance]fetchFileCacheFileWithServer_FileId:serFileId]; <span class="comment">// 根据serFileId 查询缓存表并转换为缓存model读出</span></span><br><span class="line">    <span class="keyword">if</span> (fileArray.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        RHFileCacheModel *fileModel = [fileArray firstObject]; <span class="comment">// 缓存model</span></span><br><span class="line">        <span class="built_in">NSString</span> *path = [RHCommonHelper getFullPathWithRelativePath:fileModel.PATH]; <span class="comment">// 获取图片的全路径</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithContentsOfFile:path];</span><br><span class="line">        <span class="keyword">if</span> (image) &#123; <span class="comment">// servId dataId servFileId</span></span><br><span class="line">            <span class="built_in">NSArray</span> *tmpArray = [[RHFileCacheManager sharedInstance]fetchFileCacheFileWithServId:servId dataId:dataId serverFileId:serFileId];</span><br><span class="line">            <span class="keyword">if</span> (tmpArray.count == <span class="number">0</span>) &#123;</span><br><span class="line">                fileModel.ID = [RHTools stringUUID]; <span class="comment">// uuid 随机生成的数据</span></span><br><span class="line">                fileModel.S_ATIME = [RHDateTools currenTime];</span><br><span class="line">                fileModel.S_MTIME = [RHDateTools currenTime];</span><br><span class="line">                fileModel.SERV_ID = servId;</span><br><span class="line">                fileModel.DATA_ID = dataId;</span><br><span class="line">                fileModel.SERVER_FILEID = serFileId;</span><br><span class="line">                [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来处理图片上传的情况：在上传图片接口；无论成功，失败都要将其结果保存数据库，只是失败时不存在SERVER_FILEID；其次在处理上传成功的图片，在其保存前先根据SERV_ID，DATA_ID，PATH查寻缓存表，看这条数据是否已经存在，若存在，只需更新表，把SERVER_FILEID更新至表中，若不存在，则生成一条新的数据保存至表中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   处理上传成功的图片</span></span><br><span class="line"><span class="comment"> * @param servId 服务Id</span></span><br><span class="line"><span class="comment"> * @param dataId dataId</span></span><br><span class="line"><span class="comment"> * @param serverFileId 服务端文件Id</span></span><br><span class="line"><span class="comment"> * @param fullPath 全路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)dealSuccessPhotosWithServId:(<span class="built_in">NSString</span> *)servId dataId:(<span class="built_in">NSString</span> *)dataId serverFileId:(<span class="built_in">NSString</span> *)serverFileId fileLocalFullPath:(<span class="built_in">NSString</span> *)fullPath &#123;</span><br><span class="line">    <span class="keyword">if</span> ([RHTools checkIfPreviewImage:serverFileId] &amp;&amp; [FCFileManager existsItemAtPath:fullPath]) &#123; <span class="comment">// 根据serverFileId后缀名检查是否是图片，并且本地路径下是否存在该文件</span></span><br><span class="line">        <span class="built_in">NSArray</span> *cacheOldArr = [[RHFileCacheManager sharedInstance]fetchFileCacheFileWithServId:servId dataId:dataId fullPath:fullPath];</span><br><span class="line">        RHFileCacheModel *fileModel = [[RHFileCacheModel alloc]init];</span><br><span class="line">        <span class="keyword">if</span> (cacheOldArr.count == <span class="number">0</span>) &#123; <span class="comment">// 缓存表中不存在这一条记录</span></span><br><span class="line">           fileModel = [<span class="keyword">self</span> p_getFileCacheModelWithServId:servId dataId:dataId serverFileId:serverFileId fileLocalFullPath:fullPath]; <span class="comment">// 生成缓存模型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fileModel = [cacheOldArr firstObject];</span><br><span class="line">            fileModel.PATH = [RHCommonHelper getRelativePathWithfullPath:fullPath]; <span class="comment">// 根据全路径获取相对路径</span></span><br><span class="line">            fileModel.SERVER_FILEID = serverFileId;</span><br><span class="line">        &#125;</span><br><span class="line">        [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel]; <span class="comment">// 保存到缓存表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理上传失败的图片数组</span></span><br><span class="line"><span class="comment"> * @param servId 服务iId</span></span><br><span class="line"><span class="comment"> * @param dataId dataId</span></span><br><span class="line"><span class="comment"> * @param failures 失败数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)dealPostFailPhotosWithServId:(<span class="built_in">NSString</span> *)servId dataId:(<span class="built_in">NSString</span> *)dataId failures:(<span class="built_in">NSArray</span> *)failures &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *content <span class="keyword">in</span> failures) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *fullpath = content[<span class="string">@"fileURL"</span>];</span><br><span class="line">        <span class="keyword">if</span> ([FCFileManager existsItemAtPath:fullpath]) &#123;</span><br><span class="line">            RHFileCacheModel *fileModel = [<span class="keyword">self</span> p_getFileCacheModelWithServId:servId dataId:dataId serverFileId:<span class="string">@""</span> fileLocalFullPath:fullpath];</span><br><span class="line">            [[RHFileCacheManager sharedInstance]saveFileCacheToLocalWithFileCacheModel:fileModel];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;删除逻辑:删除时首先根据SERVER_FILEID查表中数据，如果大于1，说明此文件被多个地方引用，不删除文件，仅根据SERV_ID，DATA_ID，SERVER_FILEID，删出表中这条数据；若根据SERVER_FILEID查表中数据等于1，删除文件，同时根据SERV_ID，DATA_ID，SERVER_FILEID，删出表中这条数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近在做我们公司自己的项目时，遇到了一个难题，就是随着用户使用我们公司的app时间越久，便导致app沙盒文件越来越多，严重时我查看我们公司的app使用内存量达到了&lt;code&gt;7.3G&lt;/code&gt;，查看方式，打开你的苹果手机,(&lt;code&gt;设置-通用
      
    
    </summary>
    
      <category term="技术" scheme="https://liuliangju.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://liuliangju.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>我曾经经历的CMMI3认证之关于软件开发人员的访谈</title>
    <link href="https://liuliangju.github.io/2016/10/29/%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86/%E6%88%91%E6%9B%BE%E7%BB%8F%E7%BB%8F%E5%8E%86%E7%9A%84CMMI3%E8%AE%A4%E8%AF%81%E4%B9%8B%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E8%AE%BF%E8%B0%88/"/>
    <id>https://liuliangju.github.io/2016/10/29/个人经历/我曾经经历的CMMI3认证之关于软件开发人员的访谈/</id>
    <published>2016-10-29T11:25:27.000Z</published>
    <updated>2018-04-19T12:51:38.645Z</updated>
    
    <content type="html"><![CDATA[<p>自己所在的公司申请CMMI3等级认证，本人又有幸成为了被访谈中的一员，我由于本人从属于公司的研发部的一名研发人员，所以我的身份顺理成章的也是开发人员。主评官是一名德国老外。</p><p>当时我们公司和对方约定的访谈时间是10月18日~10月21日，第一天首先是发起人见面，然后要参加被访谈的全体人员参加启动会议，下午是分别是EPG组长、CM、OT、PPQA的访谈，开发人员是19号。</p><p>我们公司一共准备了3个项目(每个项目组配备两名开发人员，一名测试人员)，我是第一个项目组的成员，早晨9点钟到达公司，大概9:15左右，会议室的人出来叫人说可以开始了，让我们进去，进入到会议室之后老外先和我们打了招呼，然后翻译在旁翻译，并且讲述访谈的原则不归咎原则，及签订保密协议。</p><p>下面是我们访谈的被问到的问题：<br>1，公司定义了哪些不同的需求获取的方式？<br>答：公司定义的需求获取的方式有：电话、邮件、调查问卷、开研讨会、静态页面效果图、原型等方式<br>2，你的项目中使用了哪些方式获取客户的需求的？获取了客户的哪些需求？<br>答：邮件、调查问卷、开研讨会、静态页面效果图；获取了客户的需求分为功能性需求和质量属性方面的需求，质量属性方面的需求可分为可维护性，安全性，易用性等等。<br>3，客户有没有对你们获取后的需求进行确认？如何确认的？<br>答：我们将用户的需求整理，制定成《用户需求说明书》并交与客户确认签字。<br>4，项目中的需求是如何进行管理的？<br>答：我们在每个阶段完成时，都填写《需求跟踪矩阵》，所以当需求变更时，我们《需求跟踪矩阵》来查看每个需求的状态，了解因变更而影响的需求范围。<br>5，你们是如何对客户的需求进行分析的？<br>答：我们采用VISO工具来分析系统，并对系统进行建模，制定出系统的业务流程图和系统架构图，当《软件需求说明书》制定完成后，由项目经理组织邀请客户，开发人员，测试人员，配置人员，质量保证人员，高层参加软件需求说明书的评审会议，在保证需求分析是满足客户需求的，并得到大家的认可。<br>6，需求的优先级和难易度是如何来定义的？<br>答：我们是根据需求的难易度来确定优先级的。<br>高 — 软件必须实现的功能，用户有明确的功能定义和要求；<br>中 — 软件应该实现的功能，用户的功能定义和要求可能是模糊的、不具体的、或低约束的，但是这类功能的缺少会导致用户的不满意，因此这类功能的具体需求应当由需求分析人员诱导用户产生并明确；<br>低 — 软件尽量实现的功能，并可根据开发进度进行取舍，但这类功能的实现将会增加用户的满意度。<br>7，公司是如何跟踪项目的需求接口需求的？<br>答：根据《用户需求说明书》指定的《软件需求说明书》中定义了软件的接口需求。并在《需求跟踪矩阵》中进行接口需求的跟踪。<br>8，如何对需求进行管理来确保需求的完整性，一致性？<br>答：通过评审会议，维护《需求跟踪矩阵》，以及周会确保需求的完整性和一致性。<br>9，需求变更的时候由谁来确认？<br>答：当需求变更的时候，由项目经理提交需求变更申请到CCB(变更控制委员会)进行确认是否变更。<br>10，你们怎么确保不同工作产品的一致性和完整性？<br>答：通过召开评审会议确保不同工作产品的一致性和完整性。<br>11，对于过程改进活动，你们参与了哪些工作？<br>答：参与了临时过程组对OSSP体系对编写，需求开发与管理，设计过程等。<br>12，需求经验和优秀实践经验如何和其他项目和组织分享？<br>答：一般有好的经验或建议，我们会向EPG反馈，EPG组长整理采纳后会存放在公司的财富库中。<br>13，在过程规范中变更如何通知你们的？<br>答：过程规范发生变更时，过程改进会形成新的基线，配置管理工程师会发布基线报告，EPG组长会安排相应人员给我们培训。<br>14，如何管理产品交付后客户的需求？<br>答：在产品交付客户后，我们给客户有1年的免费维护期，如果是原需求的变更，我们免费维护，如果新需求的变更，则另有偿维护。<br>15，公司是否通过了设计方面的指南？<br>答：是的，EPG制定了《设计过程》《实现过程》等来指导我们工作。<br>16，设计过程是什么？<br>答：项目经理指定角色，要先做《概要设计说明书》和《编码规范》，然后召开评审会议，评审通过后，再做《详细设计说明书》及《数据库设计说明书》，同时界面设计师做静态界面设计，然后由项目经理召开评审会议，评审通过后，将相关配置项由配置管理工程师入库等。<br>17，设计采用了哪些技术？<br>答：结构化设计方法：1，自顶向下  2，逐步细化  3，模块化设计   4，结构化编码<br>结构化设计步骤如下：<br>1，审核细化数据流<br>2，确定数据流程图的类型<br>3，把数据流图映射到软件模块结构，设计出模块结构的上层<br>4，基于数据流图逐步分解高层模块，设计中下层模块<br>5，对模块结构进行优化，得到更合理的软件结构<br>6，描述模块接口<br>18，目前的决策分析方法有哪些？<br>答：主要采用了经验法和类比法两种。然后采用专家法打分决策<br>19，项目中的重用组件使用前，项目组有没有进行讨论？<br>答：在《项目计划》里定义并分析了项目重用组件，并在《项目计划》会议上，对项目的组件重用进行了分析讨论。<br>20，设计阶段你们做了哪些评审，如何做的？<br>答：设计阶段有《概要设计说明书》评审，《详细设计说明书》评审；《里程碑》等评审活动，在评审会议上，由主持人组织会议持续，作者讲解评审工作的内容，回答评审人员提出的问题，会议记录人员将会议上的内容及问题进行记录，并整理到《评审记录》中，由项目经理指定并监控负责人解决评审中发现的问题。<br>21，关于这些评审，计划多少的工作量？评审的主要反馈是什么？<br>答：评审会议一般持续4个小时左右，评审主要反馈评审工件中的一些问题的个数、严重等级、分析和解决措施等。<br>22，哪些工作进行了同行评审？<br>答：《用户需求说明书》《软件需求说明书》《项目计划》《概要设计说明书》《详细设计说明书》《数据库设计说明书》《测试用例》<br>23，同行评审收集了哪些数据？如何分析的？<br>答：同行评审收集了评审工件中的问题个数、严重等级、产生的原因、解决措施，并记录在评审会议中。<br>24，你们是如何确保的设计符合需求？<br>答：我们利用《需求跟踪矩阵》来保证需求、设计、编码、测试的一致性和完整性；同时设计中的每一个阶段(概要设计阶段、详细设计阶段)都召开评审会议，确保阶段性工作产品的质量。<br>25，产品集成的顺序和环境在哪里有记录？<br>答：在《产品集成计划》中有记录<br>26，项目是怎么发布的？谁来建立，评审和最终发布？<br>答：由项目经理建立和发布项目产品，客户接收产品时，项目经理将《项目交付报告》交与客户签字。然后召开项目结项会议。<br>27，项目在每个阶段是否都建立了基线？你们是如何得知基线的建立的？<br>答：是的，当基线建立后，配置管理工程师向项目组成员发布基线报告。<br>28，你们是如何参与项目计划和估算的？<br>答：项目估算会议，根据开发经验对用户需求的功能点进行规模和工作量的估计，项目经理将每个专家的估计值进行计算，得到工作量和规模的平均值。然后参考财富库中的度量数据，进行项目的工作量估算。然后再估算出项目的成本。<br>29，你们向谁做工作汇报，回报哪些内容？<br>答：向项目经理汇报工作，汇报工作量，进度，偏差等。<br>30，项目中有什么技术风险和问题？<br>答：有人员的技术风险，也有项目管理的问题。<br>31，如何保证代码质量？<br>答：我们每天下班前，由项目经理组织开发人员进行交互代码走查，主要检查代码的编码规范和代码的逻辑性，并将发现的问题记录在《代码走查》中，同时开发人员进行单元测试，以保证代码的质量。<br>32，你们是如何进行单元测试的？测试的结果会有记录吗？结果报告存放在那里？<br>答：我们根据单元测试用例进行单元测试，采用白盒测试，测试结果记录在《测试记录跟踪表》中。<br>33，如何确定编码结束的？<br>答：1，项目经理已经确认，该软件的功能已经按照《用户需求说明书》和项目《软件需求说明书》的要求全部实现，功能和界面结合完成。<br>2，所有功能代码均已基线化。<br>3，单元测试，集成测试结束，系统预编译成功。<br>4，该单元的项目《用户使用手册》、项目《系统安装手册》等相关文档必需提交到系统测试。<br>34，项目中的源代码是如何管理的？<br>答：我们使用的是git。<br>35，你们是如何和测试人员合作的？<br>答：首先，测试出的bug有四种状态，打开，跟踪，重新打开，关闭。当测试人员发现bug后，将bug记录在《测试记录跟踪表》中，此时的bug状态是打开；接着由测试人员将《测试记录跟踪表》提交给项目经理，由项目经理指定bug修改负责人，当bug修改负责人解决bug后，将bug的状态改为“跟踪”，然后提交给测试人员，由测试人员进行验证测试，当测试人员验证测试成功，则bug状态改为“关闭”，当测试人员验证测试失败后，则bug的状态改为“重新打开”，最为bug重新处理。<br>36，编码过程中会统计哪些数据？这些数据存放在哪？<br>答：在编码阶段，我们收集项目规模，数据都记录在《项目总结报告》中。<br>37，项目经理是如何检查你们工作的？<br>答：主要根据周会，里程碑会议来检查工作，同时在平时我们发现问题也会EMAIL或走查的形式通知项目经理，项目经理也会根据《项目进度表》监控我们的工作进展情况。<br>38，你的项目是否有内部制定保证？<br>答：有PPQA是根据QA制定的《检查表》在每个检查时机处检查我的工作，并将发现的NC通过EMAIL的形式发给我，我在接到NC一天内给予反馈。</p><p>以上是作为开发人员问的问题，测试人员没怎么问，就问了一道题，还是和开发人员重合的为35题。下午，第2，3个项目一起进入会议室访谈。</p><p>第三天上午他们在会议室对访谈内容进行分析，下午快下班时召开初步发现会议让我们对他们给出的访谈分析结果提出异议。</p><p>第四天上午，最终发布会议，全员都要参加。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自己所在的公司申请CMMI3等级认证，本人又有幸成为了被访谈中的一员，我由于本人从属于公司的研发部的一名研发人员，所以我的身份顺理成章的也是开发人员。主评官是一名德国老外。&lt;/p&gt;
&lt;p&gt;当时我们公司和对方约定的访谈时间是10月18日~10月21日，第一天首先是发起人见面，
      
    
    </summary>
    
      <category term="经历" scheme="https://liuliangju.github.io/categories/%E7%BB%8F%E5%8E%86/"/>
    
    
      <category term="CMMI" scheme="https://liuliangju.github.io/tags/CMMI/"/>
    
  </entry>
  
  <entry>
    <title>iOS图片压缩</title>
    <link href="https://liuliangju.github.io/2016/09/03/iOS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/2018%E4%B9%8B%E5%89%8D/iOS%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    <id>https://liuliangju.github.io/2016/09/03/iOS基础总结/2018之前/iOS图片压缩/</id>
    <published>2016-09-03T14:01:47.000Z</published>
    <updated>2018-04-19T12:51:38.641Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在做iOS开发中，经常会遇到这样的问题，图片尺寸太大，或者文件体积太大，需要将图片压缩处理一下，然后上传服务器。<br>&emsp;&emsp;当然，也不排除一些公司要求app上传原图，但是这种方式太耗流量且很耗时间，如果网络不佳，很容易上传失败，从而会失去一些用户。</p><h3 id="1-理解概念"><a href="#1-理解概念" class="headerlink" title="1, 理解概念:"></a>1, 理解概念:</h3><p><table class="table table-bordered table-condensed"><tr><td bgcolor="Gainsboro">1, “压” 是指文件体积变小，但是像素数不变，长宽尺寸不变，那么质量可能下降。<br>2, “缩” 是指文件的尺寸变小，也就是像素数减少，而长宽尺寸变小，文件体积同样会减小。</td></tr></table></p><h3 id="2-图片“压”处理"><a href="#2-图片“压”处理" class="headerlink" title="2, 图片“压”处理:"></a>2, 图片“压”处理:</h3><p>对于“压”功能，我们可以使用UIImageJPEGRepresentation或UIImagePNGRepresentation方法实现，如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *imgData = <span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure></p><p>第一个参数是图片对象本身，第二个参数是压的系数，其值范围为(0-1);<br>UIImageJPEGRepresentation的官方注释:<table class="table table-bordered table-condensed"><tr><td bgcolor="Gainsboro">The quality of the resulting JPEG image, expressed as a value from 0.0 to 1.0. The value 0.0 represents the maximum compression (or lowest quality) while the value 1.0 represents the least compression (or best quality).</td></tr></table>关于PNG和JPEG格式压缩:<table class="table table-bordered table-condensed"><tr><td bgcolor="Gainsboro">1. <font color="purple">UIImageJPEGRepresentation</font>函数需要两个参数:图片的引用和压缩系数而<font color="purple">UIImagePNGRepresentation</font>只需要图片引用作为参数.<br>2.<font color="purple">UIImagePNGRepresentation(UIImage *image)</font>要比<font color="purple">UIImageJPEGRepresentation(UIImage* image, 1.0)</font>返回的图片数据量大很多</td></tr></table>项目中做图片上传之前，经过测试同一张拍照所得照片png大小在8M，而JPG压缩系数为0.75时候，大小只有1M。而且，将压缩系数降低对图片视觉上并没有太大的影响。<br>友情提示：<table class="table table-bordered table-condensed"><tr><td bgcolor="Gainsboro"><font color="purple">压缩系数不宜太低，通常是0.3~0.7，过小则可能会出现黑边等</font></td></tr></table></p><h3 id="3-图片“缩”处理"><a href="#3-图片“缩”处理" class="headerlink" title="3, 图片“缩”处理:"></a>3, 图片“缩”处理:</h3><p>主要通过 <font color="purple">[image drawInRect:CGRectMake(0, 0, targetWidth, targetHeight)];</font> 实现。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  1, 按图片最大边成比例缩放图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param image   图片</span></span><br><span class="line"><span class="comment"> *  @param maxSize 图片的较长那一边目标缩到的(宽度／高度)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return        等比缩放后的图片</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> - (<span class="built_in">UIImage</span> *)scaleImage:(<span class="built_in">UIImage</span> *)image maxSize:(<span class="built_in">CGFloat</span>)maxSize &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">if</span>(data.length &lt; <span class="number">200</span> * <span class="number">1024</span>)&#123;<span class="comment">//0.25M-0.5M(当图片小于此范围不压缩)</span></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageWidth = image.size.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageHeight = image.size.height;</span><br><span class="line">    <span class="built_in">CGFloat</span> targetWidth = imageWidth;</span><br><span class="line">    <span class="built_in">CGFloat</span> targetHeight = imageHeight;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageMaxSize = MAX(imageWidth, imageHeight);</span><br><span class="line">    <span class="keyword">if</span> (imageMaxSize &gt; maxSize) &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> scale = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (imageWidth &gt;= imageHeight) &#123;<span class="comment">// 宽长</span></span><br><span class="line">            scale = maxSize / imageWidth;</span><br><span class="line">            targetWidth = maxSize;</span><br><span class="line">            targetHeight = imageHeight * scale;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 高长</span></span><br><span class="line">            scale = maxSize / imageHeight;</span><br><span class="line">            targetHeight = maxSize;</span><br><span class="line">            targetWidth = imageWidth * scale;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(targetWidth, targetHeight));</span><br><span class="line">        [image drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, targetWidth, targetHeight)];</span><br><span class="line">        <span class="built_in">UIImage</span> *scaledImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        <span class="keyword">return</span> scaledImage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  2, 图片支持等比缩放</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param image   图片</span></span><br><span class="line"><span class="comment"> *  @param maxSize 缩放比例(通常0～1之间)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return        等比缩放后的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImage</span> *)scaleImage:(<span class="built_in">UIImage</span> *)image toScale:(<span class="keyword">float</span>)scaleSize &#123;</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(image.size.width *scaleSize, image.size.height * scaleSize));</span><br><span class="line">    [image drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, image.size.width * scaleSize, image.size.height * scaleSize)];</span><br><span class="line">    <span class="built_in">UIImage</span> *scaledImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> scaledImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  3, 等比缩放成自定长宽的图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param image      源图片</span></span><br><span class="line"><span class="comment"> *  @param targetSize 自定义目标图片的size</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 处理后图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)scaleImage:(<span class="built_in">UIImage</span> *)image toSize:(<span class="built_in">CGSize</span>)targetSize &#123;</span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(targetSize.width, targetSize.height));</span><br><span class="line">    [image drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, targetSize.width, targetSize.height)];</span><br><span class="line">    <span class="built_in">UIImage</span> *targetSizeImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> targetSizeImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对图片只“压”而不缩，有时候是达不到我们的需求的。因此，适当地对图片“缩“一下尺寸，就可以满足我们的需求。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据图片附获取图片大小(多少M)方法</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)imageData:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data.length &gt; <span class="number">100</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length &gt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;<span class="comment">//1M以及以上</span></span><br><span class="line">            data = <span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">0.1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length &gt; <span class="number">512</span>*<span class="number">1024</span>) &#123;<span class="comment">//0.5M-1M</span></span><br><span class="line">            data = <span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">0.5</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length &gt; <span class="number">200</span>*<span class="number">1024</span>) &#123;<span class="comment">//0.25M-0.5M</span></span><br><span class="line">            data = <span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">0.9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>验证：<br>以模拟器第二张绿叶图片为例<br>原图大小为24.9M, 4288 * 2848像素；<br>经一次<font color="purple">UIImageJPEGRepresentation</font>“压“处理<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *tmpImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:photo.photoPath];</span><br><span class="line"><span class="built_in">NSData</span> *imageData = <span class="built_in">UIImageJPEGRepresentation</span>(tmpImage, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure></p><p>图片大小为836.9K, 4288 * 2848像素；</p><p>经一次<font color="purple">UIImagePNGRepresentation</font>“压“处理<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *tmpImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:photo.photoPath];            </span><br><span class="line"><span class="built_in">NSData</span> *imageData = <span class="built_in">UIImagePNGRepresentation</span>(tmpImage);</span><br></pre></td></tr></table></figure></p><p>图片大小为24.9M, 4288 * 2848像素；几乎没变</p><p>经一次“缩“处理(笔者给予图片最大的宽度限定为640像素)<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *tmpImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:photo.photoPath];</span><br><span class="line">tmpImage = [<span class="keyword">self</span> scaleImage:tmpImage maxSize:<span class="number">640</span>];</span><br></pre></td></tr></table></figure></p><p>图片大小为795.9K, 640 * 426像素；</p><p>经一次“压缩”处理:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *tmpImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:photo.photoPath];</span><br><span class="line">tmpImage = [<span class="keyword">self</span> scaleImage:tmpImage maxSize:<span class="number">640</span>]; </span><br><span class="line"><span class="built_in">NSData</span> *imageData = <span class="built_in">UIImageJPEGRepresentation</span>(tmpImage, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure></p><p>图片大小为698K, 640 * 426像素；<br>大家可以根据实际调整不同参数以达到自己的项目要求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在做iOS开发中，经常会遇到这样的问题，图片尺寸太大，或者文件体积太大，需要将图片压缩处理一下，然后上传服务器。&lt;br&gt;&amp;emsp;&amp;emsp;当然，也不排除一些公司要求app上传原图，但是这种方式太耗流量且很耗时间，如果网络不佳，很容易上传失败，从
      
    
    </summary>
    
      <category term="技术" scheme="https://liuliangju.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://liuliangju.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
